/*
 * display.c
 *
 *  Created on: 9 de ago de 2022
 *      Author: andre
 */
#include "comum.h"

/* Structs externas */
extern QueueHandle_t fila_display;
extern QueueHandle_t fila_teclado;
extern TaskHandle_t xHandle;
extern flash_config_t s_flashDriver;

/* Variáveis externas */
extern unsigned int timerRTC;
extern volatile unsigned char flag_timer;
extern volatile unsigned char flagBuz;

/* Variáveis globais */
char data[6];
unsigned int voltageCalA_K = 0, voltageCalA_Ca = 0, voltageCalA_Cl = 0, voltageCalA_pH = 0, voltageCalA_Na = 0;
unsigned int voltageCalB_K = 0, voltageCalB_Ca = 0, voltageCalB_Cl = 0, voltageCalB_pH = 0, voltageCalB_Na = 0;
double Ck = 0, Cca = 0, Ccl = 0, CpH = 0, Cna = 0;
double Ck_standard = 0, Cca_standard = 0, Ccl_standard = 0, CpH_standard = 0, Cna_standard = 0;


void display_run( void ){

	unsigned char estado_display = 0, flagError = 0, flagCalibOk = 0;
	unsigned char menu = 0, menu_anterior = 0, respCalibA, respCalibB, readQueueKeyboard;
	unsigned int contError = 0;

	rst_off;
	for(int i = 0; i < 1000; i++ );
	rst_on;

	//FLASH_Erase(&s_flashDriver, ADDR_FLASH, 2000, kFLASH_ApiEraseKey);

	uart_config_t config;
	UART_GetDefaultConfig(&config);
	config.baudRate_Bps = 19200;
	config.enableTx     = true;
	config.enableRx     = true;
	UART_Init(UART3, &config, CLOCK_GetFreq(UART3_CLK_SRC));

	status(1);
	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_text_home_addr);
	status(1);

	send_data(0x1E);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_text_area);
	status(1);

	send_data(0xC0);
	status(1);
	send_data(0x03);
	status(1);
	send_command(Set_graphic_home_addr);
	status(1);

	send_data(0x1E);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_graphic_area);
	status(1);

	send_data(0x02);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_offset_register);
	status(1);

	send_command(Display_mode_graphic);
	status(1);

	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 4800; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	send_data(0x00);
	status(1);
	send_data(0x00);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Display_mode_text);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 480; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	// Escrita de valor 0xFF no dado para ser utilizado
	send_data(0x00);
	status(1);
	send_data(0x14);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 8; i++ ){
		send_data(0xFF);
	}
	// Escrita para 0x81 a letra A com til
	send_data(0x05);
	send_data(0x0A);
	send_data(0x04);
	send_data(0x0A);
	send_data(0x11);
	send_data(0x1F);
	send_data(0x11);
	send_data(0x00);

	// Escrita para 0x82 uma linha na 4° linha
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);
	send_data(0x7E);
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);
	send_data(0x00);

	send_command(Auto_reset);
	status(2);

	send_command(Mode_set_exor);
	status(2);

	//initEquip();

	desenho_menu1();
	desenha_fundo_menu( menu, 1 );

	send_command(Display_mode_text | Display_mode_graphic);
	status(1);

	escrita_texto(371, "1 PONTO", sizeof("1 PONTO"));

	unsigned char readRxI2c = 0;
	I2C_READ_PCF8653( &readRxI2c, Control_Status_1 );
	if( readRxI2c != 0x00 )
		configRTC();

	while(1){

		readQueueKeyboard = verifyKeyBoard(); // Leitura do teclado

		if( timerRTC > 1000 && estado_display == 0 ){ // Caso não esteja verificando erros do sistema

			/*Escreve o texto do tempo a cada segundo
			 * Criar variável global para controle do tempo RTC (timerRTC)
			 * Se timerRTC for maior que 1000
			 * 		Zera timerRTC
			 * 		Escreve os segundos na tela
			 * 		Escreve :
			 * 		Escreve os mminutos na tela
			 * 		Escreve :
			 * 		Escreve as horas na tela
			 */

			timerRTC = 0;
			readRxI2c = 0;
			I2C_READ_PCF8653( &readRxI2c, Hours );
			escrita_texto(71, numtolcd( bcdtodec( readRxI2c & 0x3F ), NUM ), 3);
			escrita_texto(73, ":", 2);
			I2C_READ_PCF8653( &readRxI2c, Minutes );
			escrita_texto(74, numtolcd( bcdtodec( readRxI2c & 0x7F ), NUM ), 3);
			escrita_texto(76, ":", 2);
			I2C_READ_PCF8653( &readRxI2c, VL_seconds );
			escrita_texto(77, numtolcd( bcdtodec( readRxI2c & 0x7F ), NUM ), 3);


		}

		switch(estado_display){
		case 0:

			if( readQueueKeyboard == left ){
				if( menu == 0 )
					menu = 8;
				else
					menu--;
			}
			else if( readQueueKeyboard == right ){
				if( menu == 8 )
					menu = 0;
				else
					menu++;
			}else if( readQueueKeyboard == um || ( readQueueKeyboard == yes && menu == 0 ) ){
				estado_display = 1;
				menu = 0;
				menu_anterior = 0;
				clear_display_text();
			}else if( readQueueKeyboard == dois || ( readQueueKeyboard == yes && menu == 1 ) ){
				estado_display = 2;
				menu = 1;
				menu_anterior = 1;
				clear_display_text();
			}
			// Se tecla igual a 3 ou menu igual a 2 e tecla igual a yes
			else if( readQueueKeyboard == tres || ( readQueueKeyboard == yes && menu == 2 ) ){
				estado_display = 3;	// Estado vai para a posição 3
				menu = 2;	// Salva a posição do menu
				menu_anterior = 2;	// Salva a posição do menu anterior
				clear_display_text();	// Limpa a tela
				telaManutencao();	// Escreve tela de Manutenção

			}
			else if( readQueueKeyboard == quatro || ( readQueueKeyboard == yes && menu == 3 ) ){
				estado_display = 4;
				menu = 3;
				menu_anterior = 3;
				clear_display_text();
				escrita_texto( 0x08, "TESTE DE SORO", sizeof("TESTE DE SORO"));
			}

			readQueueKeyboard = 0;
			if( menu_anterior != menu ){
				writeMenuName(menu);
			}
			menu_anterior = menu;
			break;

		case 1:

			flagError = calibA(0);
			clear_display_text();
			desenho_menu1();
			desenha_fundo_menu( menu, 1 );
			writeMenuName(menu);
			send_command(Display_mode_text | Display_mode_graphic);
			status(1);
			estado_display = 0;
			/*if( controlMenu == 0 ){

				respCalib = calibA(0);

				if( respCalib == 0 )
					controlMenu = 1;
				else if( respCalib == 2 ){

					controlMenu = 0;
					clear_display_text();
					desenho_menu1();
					desenha_fundo_menu( menu, 1 );
					writeMenuName(menu);
					send_command(Display_mode_text | Display_mode_graphic);
					status(1);
					estado_display = 0;

				}

			}else if( controlMenu == 1 ){

				clearLine(3);
				clearLine(5);
				clearLine(7);
				clearLine(9);
				clearLine(11);
				contError = verifyError(TYPEA, NOABNORMAL);
				if( contError != 0 ){
					clearLine(13);
					controlMenu = 2;
					flagError = 1;
				}
				else{
					flagError = 0;
					controlMenu = 0;
					clear_display_text();
					desenho_menu1();
					desenha_fundo_menu( menu, 1 );
					writeMenuName(menu);
					send_command(Display_mode_text | Display_mode_graphic);
					status(1);
					estado_display = 0;
				}
			}else if( controlMenu == 2 ){

				escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));

				if( readQueueKeyboard == yes ){
					estado_display = 1;
					controlMenu = 0;
					clear_display_text();

				}
				else if( readQueueKeyboard == no ){

					controlMenu = 0;
					clear_display_text();
					desenho_menu1();
					desenha_fundo_menu( menu, 1 );
					writeMenuName(menu);
					send_command(Display_mode_text | Display_mode_graphic);
					status(1);
					estado_display = 0;

				}
				readQueueKeyboard = 0;

			}*/

			break;

		case 2:

			respCalibA = calibA(0);
			if( respCalibA == 0 ){
				clear_display_text();
				respCalibB = calibB();
				if( respCalibB == 0 ){
					calibValues();
					flagCalibOk = 1;
				}
			}else if( respCalibA != 0 || respCalibB != 0 )
				flagCalibOk = 0;
			clear_display_text();
			desenho_menu1();
			desenha_fundo_menu( menu, 1 );
			writeMenuName(menu);
			send_command(Display_mode_text | Display_mode_graphic);
			status(1);
			estado_display = 0;
			/*			if( controlMenu == 0 ){

				respCalibA = calibA(0);

				if( respCalibA == 0 )
					controlMenu = 1;

			}else if( controlMenu == 1 ){
				if( !flagCalibB ){
					clearLine(3);
					clearLine(5);
					clearLine(7);
					clearLine(9);
					clearLine(11);
					contError = verifyError(TYPEA, NOABNORMAL);
				}
				if( contError != 0 && !flagCalibB ){
					clearLine(13);
					controlMenu = 3;
					flagError = 1;
				}
				else{

					flagError = 0;
					respCalibB = calibB();
					if( respCalibB == 0 ){
						controlMenu = 2;
					}

				}
			}
			else if( controlMenu == 2 ){
				clearLine(3);
				clearLine(5);
				clearLine(7);
				clearLine(9);
				clearLine(11);
				contError = verifyError(TYPEB, ABNORMAL);
				if( contError != 0 ){
					clearLine(13);
					controlMenu = 4;
					flagError = 1;
				}
				else{

					calibA(1);
					flagError = 0;
					calibValues();
					flagCalibOk = 1;
					controlMenu = 0;
					clear_display_text();
					desenho_menu1();
					desenha_fundo_menu( menu, 1 );
					writeMenuName(menu);
					send_command(Display_mode_text | Display_mode_graphic);
					status(1);
					estado_display = 0;

				}
			}
			else if( controlMenu == 3 || controlMenu == 4 ){

				escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));

				if( readQueueKeyboard == yes ){
					estado_display = 2;
					clear_display_text();
					if( controlMenu == 3 ){
						controlMenu = 0;
					}
					else if( controlMenu == 4 ){
						flagCalibB = 1;
						controlMenu = 1;

					}
				}
				else if( readQueueKeyboard == no ){

					flagCalibB = 0;
					controlMenu = 0;
					calibA(1);
					clear_display_text();
					desenho_menu1();
					desenha_fundo_menu( menu, 1 );
					writeMenuName(menu);
					send_command(Display_mode_text | Display_mode_graphic);
					status(1);
					estado_display = 0;

				}
				readQueueKeyboard = 0;

			}*/

			break;

		case 3:

			readQueueKeyboard = verifyKeyBoard();	// Lê o teclado

			if( readQueueKeyboard == um ){	// Se teclado igual a 1
				condicionamento();	// Chama função de condicionamento
				//estado_display = 2;
			}

			else if(  readQueueKeyboard == dois ){	// Senão se teclado igual a 2
				desproteinizacao();	// Chama função de desproteinização
				//estado_display = 2;	// Estado display recebe 2
			}
			else if(  readQueueKeyboard == tres ){	//Senão se teclado igual a 3
				calibA(1);	// Chama função lavando (calibA(1))
				clearLine(13);

			}
			else if(  readQueueKeyboard == quatro )	{// Senão se teclado igual a 4
				limpezaTubulacao();	// Chama função limpeza
				estado_display = 2;	// Estado display recebe 2
				clear_display_text();	// Limpa a tela
			}
			else if(  readQueueKeyboard == no ){	// Senão se teclado igual a NO

				clear_display_text();	// Limpa a tela
				desenho_menu1();	// Desenha Menu 1
				desenha_fundo_menu( menu, 1 );	// Desenha o fundo do display
				writeMenuName(menu);	// Desenha o nome do menu anterior
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;// Estado display recebe 0

			}

			break;

		case 4:

			if( flagCalibOk ){

				testeSoro();
				clear_display_text();
				desenho_menu1();
				desenha_fundo_menu( menu, 1 );
				writeMenuName(menu);
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;

			}
			else{

				clear_display_text();
				escrita_texto(210, "Calibre antes passar amostra", sizeof("Calibre antes passar amostra"));
				escrita_texto(270, "K,Na,Cl,Ca,pH sem calibrar", sizeof("K,Na,Cl,Ca,pH sem calibrar"));
				vTaskDelay(2000);
				clear_display_text();
				desenho_menu1();
				desenha_fundo_menu( menu, 1 );
				writeMenuName(menu);
				send_command(Display_mode_text | Display_mode_graphic);
				status(1);
				estado_display = 0;

			}
			break;
		}
	}

}

unsigned char status( unsigned char tipo ){

	unsigned char reg = 0;

	db0_on;
	db1_on;
	db2_on;
	db3_on;
	db4_on;
	db5_on;
	db6_on;
	db7_on;

	rst_on;
	wr_on;
	rd_off;
	cd_on;
	ce_off;

	if( tipo == 1 ){
		reg = 0;
		while(!((reg & 0x03) == 0x03)){

			reg = ( db7_read << 7 )
																																								| ( db6_read << 6 )
																																								| ( db5_read << 5 )
																																								| ( db4_read << 4 )
																																								| ( db3_read << 3 )
																																								| ( db2_read << 2 )
																																								| ( db1_read << 1 )
																																								| db0_read;

			reg = reg;

		}
	}
	else{

		reg = 0;
		while(!((reg & 0x80) == 0x80)){

			reg = ( db7_read << 7 )
																																								| ( db6_read << 6 )
																																								| ( db5_read << 5 )
																																								| ( db4_read << 4 )
																																								| ( db3_read << 3 )
																																								| ( db2_read << 2 )
																																								| ( db1_read << 1 )
																																								| db0_read;

			reg = reg;

		}


	}

	ce_on;
	wr_on;
	rd_on;
	cd_on;

	return reg;

}

unsigned char read_data( void ){

	unsigned char reg;

	db0_on;
	db1_on;
	db2_on;
	db3_on;
	db4_on;
	db5_on;
	db6_on;
	db7_on;

	rst_on;
	wr_on;
	rd_off;
	cd_off;
	ce_off;

	reg = ( db7_read << 7 )
																																						| ( db6_read << 6 )
																																						| ( db5_read << 5 )
																																						| ( db4_read << 4 )
																																						| ( db3_read << 3 )
																																						| ( db2_read << 2 )
																																						| ( db1_read << 1 )
																																						| db0_read;

	reg = reg;

	ce_on;
	wr_on;
	rd_on;
	cd_on;

	return reg;

}

void send_data( unsigned char data ){

	if( data & 0x01 )
		db0_on;
	else
		db0_off;

	if( data & 0x02 )
		db1_on;
	else
		db1_off;

	if( data & 0x04 )
		db2_on;
	else
		db2_off;

	if( data & 0x08 )
		db3_on;
	else
		db3_off;

	if( data & 0x10 )
		db4_on;
	else
		db4_off;

	if( data & 0x20 )
		db5_on;
	else
		db5_off;

	if( data & 0x40 )
		db6_on;
	else
		db6_off;

	if( data & 0x80 )
		db7_on;
	else
		db7_off;

	cd_off;
	wr_off;
	rd_on;
	ce_off;
	ce_on;
	cd_on;
	wr_on;
	rd_on;



}

void send_command( unsigned char command ){

	if( command & 0x01 )
		db0_on;
	else
		db0_off;

	if( command & 0x02 )
		db1_on;
	else
		db1_off;

	if( command & 0x04 )
		db2_on;
	else
		db2_off;

	if( command & 0x08 )
		db3_on;
	else
		db3_off;

	if( command & 0x10 )
		db4_on;
	else
		db4_off;

	if( command & 0x20 )
		db5_on;
	else
		db5_off;

	if( command & 0x40 )
		db6_on;
	else
		db6_off;

	if( command & 0x80 )
		db7_on;
	else
		db7_off;

	cd_on;
	wr_off;
	rd_on;
	ce_off;

	wr_on;
	rd_on;
	cd_on;
	ce_on;

}

void linha_horizontal8( unsigned char pos_y, unsigned char quant_dados8 ){

	unsigned int addr = 0x781 + pos_y * 30;

	if( pos_y > 55 || quant_dados8 > 28 )
		return;

	for( int j = 0; j < quant_dados8; j++ ){
		send_data((addr + j) & 0xFF);
		status(1);
		send_data((addr + j) >> 8);
		status(1);
		send_command(Set_address_pointer);
		status(1);

		send_command(Set_data_auto_write);
		status(2);

		send_data(0xFF);
		status(1);

		send_command(Auto_reset);
		status(2);
	}

}

void linha_horizontal( unsigned char pos_x, unsigned char pos_y, unsigned char quant_dados ){

	if( pos_y > 55 || quant_dados > 239 )
		return;
	for( int i = pos_x; i < pos_x + quant_dados; i++ )
		pixel( i, pos_y, 1 );

}

void linha_vertical( unsigned char pos_x, unsigned char pos_y, unsigned char quant_dados ){

	if( pos_x > 239 || quant_dados > 55 )
		return;
	for( int i = pos_y; i < pos_y + quant_dados; i++ )
		pixel(pos_x, i, 1);

}

void pixel( unsigned char pos_x, unsigned char pos_y, unsigned char on_off ){

	unsigned char dado = 0, data = 0;
	unsigned int addr = 0x780, coluna, linha;
	if( pos_x > 239 || pos_y > 56 )
		return;
	coluna = pos_x / 8;
	linha = 0x1E * pos_y;
	addr += linha + coluna;

	send_data(addr & 0xFF);
	status(1);
	send_data(addr >> 8);
	status(1);
	send_command(Set_address_pointer);
	status(1);

	send_command(0xC5);
	status(1);
	data = read_data();
	status(1);

	if( data )
		dado = data;

	if( on_off )
		dado |=  (0x80  >> ( pos_x % 8 ) );
	else
		dado &= ~(0x80  >> ( pos_x % 8 ) );

	send_data(dado);
	status(1);
	send_command(0xC4);
	status(1);

}

void desenha_fundo_menu( unsigned char posicao, unsigned char on_off ){


	// Escreve a tela no texto para fazer o EXOR
	for( int j = 0; j < 7; j++ ){
		send_data((0x79 + posicao*7 + j*30)& 0xFF);
		send_data((0x79 + posicao*7 + j*30) >> 8);
		send_command(Set_address_pointer);
		status(1);

		send_command(Set_data_auto_write);
		status(2);

		for( int i = 0; i < 7; i++ ){
			if( on_off )
				send_data(0x80);
			else
				send_data(0x00);
		}
		send_command(Auto_reset);
		status(2);
	}

}

void desenho_menu1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x8 ,0x0 ,0x4 ,0x0 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1C ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x2 ,0x0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x3E ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x2 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x0 ,0x1 ,0x0 ,0x1 ,0x80 ,0x3E ,0x0 ,0x7 ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x77 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x4 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x40 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x3C ,0x6 ,0xF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xE3 ,0x80 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x8 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x38 ,0x7 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xE3 ,0xC0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x10 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x38 ,0xF ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0xC1 ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x20 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x83 ,0xFF ,0x80 ,0x80 ,0x1 ,0x80 ,0x1F ,0xE ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0x80 ,0xF0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x84 ,0x0 ,0x40 ,0x80 ,0x1 ,0x80 ,0x1F ,0xDE ,0x7F ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0xF ,0x0 ,0x78 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x88 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0xF ,0xFC ,0x7C ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x1E ,0x0 ,0x3C ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x90 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x1F ,0xF8 ,0x3D ,0xFE ,0x0 ,0x1 ,0x80 ,0x0 ,0x3C ,0x0 ,0x1E ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xA0 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x1F ,0x80 ,0x3F ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x78 ,0x0 ,0xF ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x40 ,0xC0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC0 ,0x0 ,0x20 ,0x80 ,0x1 ,0x80 ,0x3F ,0x0 ,0x3F ,0xFF ,0x0 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0x7 ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x41 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x40 ,0x80 ,0x1 ,0x80 ,0x3F ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x3 ,0xC0 ,0x0 ,0x1 ,0xE0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x42 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x80 ,0x80 ,0x1 ,0x80 ,0x3C ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x7 ,0x80 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x44 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,0x80 ,0x1 ,0x80 ,0x3C ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x48 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x80 ,0x1 ,0x80 ,0x7F ,0x0 ,0x3F ,0xFC ,0x0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x50 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x4 ,0x0 ,0x80 ,0x1 ,0x80 ,0x73 ,0x80 ,0x3F ,0xF3 ,0xE0 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x60 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xF8 ,0x1 ,0x0 ,0x1 ,0x87 ,0xF1 ,0xC0 ,0x3F ,0xF3 ,0xF8 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x2 ,0x0 ,0x1 ,0x8F ,0xE0 ,0xFF ,0x3F ,0xF3 ,0xFE ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x0 ,0x4 ,0x0 ,0x1 ,0x9F ,0xE0 ,0xFF ,0x3F ,0xF3 ,0xFF ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x40 ,0x0 ,0x8 ,0x0 ,0x1 ,0xBB ,0xF0 ,0x7F ,0x3F ,0xE3 ,0xFF ,0x81 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x10 ,0x0 ,0x1 ,0xB0 ,0xF8 ,0x7F ,0x0 ,0x3 ,0xC7 ,0xC1 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x20 ,0x0 ,0x1 ,0xB0 ,0x38 ,0x3F ,0x0 ,0x2 ,0x0 ,0x7D ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x40 ,0x0 ,0x1 ,0xA0 ,0x38 ,0x3 ,0x0 ,0x3 ,0x7 ,0xF7 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x80 ,0x0 ,0x1 ,0x80 ,0x38 ,0x1 ,0x0 ,0x3 ,0xC ,0x7 ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x7F ,0x0 ,0x0 ,0x1 ,0x80 ,0x38 ,0x3 ,0x0 ,0x3 ,0x8 ,0x3F ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x80 ,0x0 ,0x0 ,0x1 ,0x80 ,0x30 ,0x3 ,0x0 ,0x3 ,0x83 ,0xFF ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x70 ,0x6 ,0x0 ,0x3 ,0x87 ,0xFF ,0x80 ,0x70 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x60 ,0x4 ,0x0 ,0x1 ,0x87 ,0xFF ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0x0 ,0x1 ,0xC7 ,0xE1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x0 ,0xE ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x0 ,0x0 ,0xC7 ,0x1 ,0x80 ,0x18 ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x10 ,0x0 ,0x0 ,0xC0 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x30 ,0x7 ,0x80 ,0x40 ,0x1 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x20 ,0x1E ,0xC0 ,0x60 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x0 ,0x38 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x60 ,0x78 ,0x70 ,0x60 ,0x1 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x41 ,0xC0 ,0x18 ,0x20 ,0x1 ,0x80 ,0x3 ,0x80 ,0x0 ,0x0 ,0xE0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xC7 ,0x0 ,0xC ,0x20 ,0x1 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x83 ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x0 ,0x60 ,0x0 ,0x1 ,0xF0 ,0x1 ,0x80 ,0x0 ,0xF8 ,0x0 ,0xF ,0x80 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x60 ,0x1 ,0x80 ,0x0 ,0x3E ,0x0 ,0xE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x40 ,0x1 ,0x80 ,0x0 ,0x1F ,0xC0 ,0x7C ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x8E ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x40 ,0x80 ,0x0 ,0x1 ,0x91 ,0x0 ,0x80 ,0x0 ,0x0 ,0x80 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x7F ,0x80 ,0x0 ,0x1 ,0x81 ,0x0 ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};

	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_menu2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x0 ,0x7 ,0x80 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1C ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x80 ,0x0 ,0x0 ,0x38 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x3E ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xC0 ,0x0 ,0x3 ,0xC1 ,0x80 ,0x0 ,0x0 ,0x7C ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x1C ,0x0 ,0x0 ,0x61 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xF8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFC ,0x3 ,0x80 ,0x0 ,0x21 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFF ,0x0 ,0x70 ,0x6 ,0x21 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x5 ,0x80 ,0xE4 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFC ,0x0 ,0x0 ,0x61 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0xF ,0x83 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0x80 ,0x1 ,0xC1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x1F ,0x3 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xE0 ,0x7 ,0x81 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x1A ,0x7 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xF8 ,0x1E ,0x1 ,0x80 ,0x0 ,0xF ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x38 ,0xF ,0xE0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFE ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0xC7 ,0xFF ,0xFF ,0xFF ,0xC6 ,0x1 ,0x80 ,0x30 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x20 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x1 ,0x0 ,0xFE ,0x1 ,0x0 ,0x1 ,0x80 ,0xC0 ,0xE ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xFF ,0xE0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x2 ,0x80 ,0xFE ,0x2 ,0x80 ,0x1 ,0x81 ,0xC0 ,0xC ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0xC1 ,0x80 ,0x2 ,0x80 ,0xFE ,0x2 ,0x80 ,0x1 ,0x81 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x6 ,0xC0 ,0xFE ,0x6 ,0xC0 ,0x1 ,0x83 ,0x0 ,0x3E ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x4 ,0x40 ,0xFE ,0x4 ,0x40 ,0x1 ,0x87 ,0x0 ,0x3F ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x4 ,0x40 ,0xFE ,0x4 ,0x40 ,0x1 ,0x8E ,0x0 ,0x67 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0xC ,0x60 ,0xFE ,0xC ,0x60 ,0x1 ,0x87 ,0x80 ,0x73 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x7F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x8 ,0x20 ,0xFE ,0x8 ,0x20 ,0x1 ,0x8B ,0x80 ,0xEC ,0xF0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFF ,0x0 ,0x81 ,0x80 ,0x8 ,0x20 ,0xFE ,0x8 ,0x20 ,0x1 ,0x9F ,0x9 ,0xDF ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFF ,0x1 ,0x81 ,0x80 ,0x18 ,0x30 ,0xFE ,0x18 ,0x30 ,0x1 ,0x9E ,0x1F ,0xFF ,0x3E ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x7 ,0xC7 ,0xFF ,0xFF ,0x1 ,0x1 ,0x80 ,0x10 ,0x10 ,0xFE ,0x10 ,0x10 ,0x1 ,0x96 ,0x1F ,0xFF ,0xFF ,0x80 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0x3C ,0x0 ,0x7F ,0xFF ,0x3 ,0x1 ,0x80 ,0x10 ,0x10 ,0xFE ,0x10 ,0x10 ,0x1 ,0xB0 ,0x3B ,0x1F ,0xBB ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x80 ,0xC0 ,0x0 ,0xF ,0xFF ,0x6 ,0x1 ,0x80 ,0x30 ,0x18 ,0xFE ,0x30 ,0x18 ,0x1 ,0xF8 ,0x30 ,0x7 ,0xDF ,0xFC ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x81 ,0x80 ,0x0 ,0x3 ,0xFE ,0xE ,0x1 ,0x80 ,0x20 ,0x8 ,0xFE ,0x20 ,0x8 ,0x1 ,0xFE ,0x38 ,0x3 ,0xF7 ,0x3E ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0xFE ,0xC ,0x1 ,0x80 ,0x20 ,0x8 ,0xFE ,0x20 ,0x8 ,0x1 ,0xBF ,0xB0 ,0x0 ,0xFF ,0xF3 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x86 ,0x0 ,0x0 ,0x2 ,0xF ,0xE0 ,0x1 ,0x80 ,0x60 ,0xC ,0xFE ,0x60 ,0xC ,0x1 ,0x9F ,0xF0 ,0x0 ,0x3A ,0xD9 ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x1 ,0x87 ,0x0 ,0x0 ,0x1C ,0x40 ,0x80 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x9F ,0xE0 ,0x0 ,0xD ,0x64 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x87 ,0x80 ,0x0 ,0xF8 ,0xC1 ,0x80 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x87 ,0xC0 ,0x0 ,0xE ,0x9B ,0xBF ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xFF ,0xFF ,0xFF ,0xFE ,0x1 ,0x87 ,0xFF ,0xFF ,0xE1 ,0x81 ,0x0 ,0x1 ,0x80 ,0x40 ,0x4 ,0xFE ,0x40 ,0x4 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x6 ,0xCC ,0xCF ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x87 ,0xFF ,0xFC ,0x3 ,0x1 ,0x0 ,0x1 ,0x80 ,0xFF ,0xFE ,0xFE ,0xFF ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x3 ,0x64 ,0x77 ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x83 ,0xFF ,0x0 ,0xE ,0x83 ,0x0 ,0x1 ,0x80 ,0x7F ,0xFC ,0xFE ,0x7F ,0xFC ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0xBA ,0x9 ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xFF ,0xFF ,0xFF ,0xFC ,0x1 ,0x81 ,0xFF ,0x81 ,0xF9 ,0x83 ,0x0 ,0x1 ,0x80 ,0x3F ,0xF8 ,0xFE ,0x3F ,0xF8 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xFD ,0xB3 ,0x39 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFF ,0xFF ,0xFF ,0xF8 ,0x1 ,0x80 ,0xFF ,0x80 ,0x0 ,0x41 ,0x0 ,0x1 ,0x80 ,0x1F ,0xF0 ,0xFE ,0x1F ,0xF0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3F ,0xCD ,0x8F ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xF0 ,0x1 ,0x80 ,0xFF ,0x0 ,0x0 ,0xC3 ,0x0 ,0x1 ,0x80 ,0xF ,0xE0 ,0xFE ,0xF ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xFE ,0x6F ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xFF ,0xE0 ,0x1 ,0x80 ,0xFF ,0x80 ,0x0 ,0x83 ,0x0 ,0x1 ,0x80 ,0x7 ,0xC0 ,0xFE ,0x7 ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xD ,0xFD ,0xB7 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x1 ,0x9F ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x7F ,0x5F ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0x80 ,0x7F ,0x0 ,0x1 ,0xBE ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xBF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xFE ,0x0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x3 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFD ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x7F ,0x0 ,0x2 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7D ,0xF9 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x3F ,0xF0 ,0x4 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x1 ,0x80 ,0x3F ,0xFE ,0x0 ,0x30 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1F ,0xFF ,0xC0 ,0xF0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xF1 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x33 ,0xFE ,0x3 ,0x90 ,0x0 ,0x1 ,0x9F ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x38 ,0x1C ,0xC ,0x30 ,0x0 ,0x1 ,0x81 ,0x0 ,0x3 ,0xFF ,0x80 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x3E ,0x0 ,0x0 ,0xF0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x7 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x3F ,0x0 ,0x3 ,0xC0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x7 ,0xE0 ,0xF8 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x1 ,0xE1 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_menu3( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x60 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x6 ,0x3F ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xC1 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFC ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFD ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFB ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xE7 ,0x38 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0x1F ,0xC ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xF9 ,0x6 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x1 ,0x3 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x60 ,0xF ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xE0 ,0x3B ,0x1 ,0x1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xC1 ,0xF3 ,0xFF ,0x21 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x9F ,0xC3 ,0xFF ,0x31 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xD8 ,0x3 ,0xFF ,0x31 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0xD8 ,0x3 ,0xFF ,0xB1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x98 ,0x1F ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xDF ,0xFF ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x6F ,0xC7 ,0xFF ,0xF1 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x83 ,0x40 ,0x7 ,0xFF ,0xFF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFB ,0xE0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0xFF ,0xEB ,0x60 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xEE ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xE7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0xEF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xF3 ,0xEF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xE3 ,0xEF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xC1 ,0xFF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x81 ,0xFF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0x0 ,0xFF ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFE ,0x0 ,0x7F ,0xE0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFE ,0x0 ,0x7F ,0xF0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFC ,0x0 ,0x3F ,0xF8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x3F ,0xFC ,0x0 ,0x1F ,0xF0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x1F ,0xF8 ,0x0 ,0x1F ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x7 ,0xF8 ,0x0 ,0xF ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8F ,0x1 ,0xF0 ,0x0 ,0xE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x30 ,0x0 ,0x18 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x8, "MENU PRINCIPAL", sizeof("MENU PRINCIPAL"));

}

void desenho_configuracao1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x83 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x2 ,0x0 ,0xC8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x1 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xD0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xE7 ,0xC3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xE0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xFF ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xF0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFB ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3 ,0xFF ,0x80 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xD8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xF9 ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0x83 ,0xC0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xC8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0x3D ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xE ,0x8 ,0xE0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xBF ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0x8 ,0x60 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFC ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x18 ,0x30 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0xC1 ,0xFF ,0x0 ,0x1 ,0x80 ,0x0 ,0x18 ,0x18 ,0x30 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFE ,0x3C ,0x3F ,0x80 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xF8 ,0x7E ,0x7 ,0xC0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x2 ,0x0 ,0xC3 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xE0 ,0xFF ,0x7 ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xE3 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xC0 ,0xEF ,0x83 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xD3 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x0 ,0xFF ,0xBE ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xCB ,0x1C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0x0 ,0xE3 ,0xBE ,0x78 ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC7 ,0x64 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0x0 ,0xFF ,0x9E ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xC3 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x7F ,0x3E ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x3E ,0x7E ,0x1E ,0x1 ,0x83 ,0x87 ,0xFF ,0xEF ,0xFF ,0xC1 ,0x1 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x0 ,0x0 ,0xFE ,0xE ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x1 ,0xF8 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x83 ,0xFF ,0xC7 ,0xC1 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF8 ,0x0 ,0x3 ,0xE0 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x1 ,0xFF ,0xCF ,0xE1 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF8 ,0x0 ,0x7 ,0xD8 ,0xF ,0x1 ,0x83 ,0x87 ,0xFF ,0x83 ,0xFF ,0xDF ,0xF1 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x2 ,0x0 ,0xFD ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFE ,0x0 ,0x7 ,0x98 ,0x3F ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x4 ,0x0 ,0xC5 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0xF ,0xFE ,0x7F ,0x1 ,0x83 ,0x87 ,0xFF ,0xC7 ,0xFF ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0x8 ,0x0 ,0xC1 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0x1F ,0xFE ,0x7F ,0x1 ,0x83 ,0x87 ,0xFC ,0x0 ,0x7F ,0xC3 ,0x81 ,0x9F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x1 ,0x10 ,0x0 ,0xC1 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xFF ,0x0 ,0x3F ,0xF8 ,0x3F ,0x1 ,0x83 ,0x87 ,0xF8 ,0x0 ,0x3F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC5 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF0 ,0x0 ,0x7F ,0x98 ,0xF ,0x1 ,0x83 ,0x87 ,0xF0 ,0x0 ,0x1F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xFD ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF8 ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x9F ,0xF7 ,0xF3 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0xE0 ,0x0 ,0x0 ,0x0 ,0x7 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0xF8 ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x8F ,0xE7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x87 ,0xC7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xFC ,0x0 ,0x0 ,0x0 ,0xF ,0x1 ,0x83 ,0x87 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x1C ,0x0 ,0x0 ,0x0 ,0x38 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x81 ,0x7 ,0xE7 ,0x1 ,0x9F ,0xC3 ,0x81 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x0 ,0x0 ,0x1E ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x2 ,0x0 ,0xFC ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x0 ,0x0 ,0x0 ,0x3C ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x3 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x39 ,0x80 ,0x0 ,0x4 ,0x0 ,0xC4 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x0 ,0x0 ,0x0 ,0x78 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x8 ,0x0 ,0xC1 ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x80 ,0x0 ,0x0 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x1 ,0x10 ,0x0 ,0xC0 ,0x70 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC0 ,0x0 ,0x1 ,0xF0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0xA0 ,0x0 ,0xC5 ,0x90 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xE0 ,0x0 ,0x3 ,0xE0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x40 ,0x0 ,0xFD ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xF0 ,0x1C ,0x7 ,0xC0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x10 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFC ,0x1C ,0xF ,0x80 ,0x1 ,0x80 ,0x7 ,0xFF ,0x10 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x9C ,0x7F ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x18 ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x1C ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x9C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x39 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x1 ,0x80 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x2 ,0x0 ,0x3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x1 ,0xE1 ,0xE0 ,0x0 ,0x1 ,0x8E ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x8F ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x4 ,0x0 ,0x3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x1 ,0xE1 ,0xF0 ,0x0 ,0x1 ,0x91 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x8 ,0x0 ,0xFB ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x61 ,0xE0 ,0xF8 ,0x0 ,0x1 ,0x81 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x1 ,0x10 ,0x0 ,0xCB ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0xF9 ,0xC0 ,0xF8 ,0x0 ,0x1 ,0x82 ,0x7 ,0xFF ,0x3C ,0xFF ,0xC0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0xA0 ,0x0 ,0xFB ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0xFF ,0xC1 ,0xFC ,0x0 ,0x1 ,0x84 ,0x7 ,0xFF ,0xFF ,0xFF ,0xC0 ,0x1 ,0x80 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x40 ,0x0 ,0xC3 ,0x30 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x7F ,0x83 ,0xFC ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x1F ,0x87 ,0xFC ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x87 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x81);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_configuracao2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xF0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0x1F ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0x3 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xC ,0xC0 ,0xF8 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x3C ,0x38 ,0x3E ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x80 ,0x0 ,0xFE ,0x6 ,0x7 ,0x80 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x80 ,0x1 ,0xBF ,0xFF ,0x80 ,0x80 ,0x70 ,0x78 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0xF8 ,0x7C ,0x0 ,0x60 ,0xC ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0xF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0xE0 ,0x30 ,0x0 ,0x30 ,0xE0 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xE0 ,0x1 ,0x80 ,0x4 ,0x0 ,0x0 ,0x3 ,0xC7 ,0x1 ,0xE8 ,0x6 ,0x0 ,0xF ,0x1 ,0xC8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3F ,0xF0 ,0x1 ,0x80 ,0x44 ,0x0 ,0x0 ,0x77 ,0xFF ,0xC1 ,0xE2 ,0x1 ,0x80 ,0xC ,0x6 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x7 ,0xFF ,0xE0 ,0xF1 ,0xE0 ,0x80 ,0x40 ,0xC0 ,0x38 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x1F ,0xFF ,0xB0 ,0x31 ,0xE0 ,0x40 ,0x31 ,0x0 ,0xE0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7F ,0xF0 ,0x1 ,0x80 ,0x7 ,0x80 ,0x1F ,0xFE ,0x38 ,0x11 ,0xE8 ,0xC ,0x0 ,0x1C ,0x0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x1 ,0x80 ,0xF ,0x80 ,0x3F ,0xFC ,0x3C ,0x11 ,0xF2 ,0x3 ,0x0 ,0xE0 ,0x0 ,0x8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x1F ,0xFF ,0xF0 ,0x1 ,0x90 ,0xF ,0x80 ,0x3F ,0xF0 ,0xFE ,0x1 ,0xE4 ,0x80 ,0x83 ,0x0 ,0x0 ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xF ,0xFF ,0xE0 ,0x1 ,0x80 ,0xF ,0x80 ,0x3F ,0x83 ,0xFF ,0x81 ,0xF9 ,0x0 ,0x7C ,0x0 ,0x1 ,0xE8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC0 ,0x1 ,0x83 ,0xF ,0x8F ,0x3F ,0xF ,0xFF ,0xF1 ,0xF6 ,0xD0 ,0x10 ,0x0 ,0x2 ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x3 ,0xFF ,0x80 ,0x1 ,0x87 ,0xBF ,0xCF ,0x3E ,0x1F ,0xF0 ,0x1 ,0xED ,0x8C ,0x10 ,0x0 ,0x1F ,0x28 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x19 ,0xFC ,0x0 ,0x1 ,0x87 ,0xFF ,0xFF ,0x3C ,0xF ,0xF0 ,0x1 ,0xE2 ,0x53 ,0x10 ,0x0 ,0x7D ,0xB8 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x38 ,0xFC ,0x0 ,0x1 ,0x83 ,0xFF ,0xFE ,0x3C ,0x1F ,0xF0 ,0x1 ,0xFC ,0x49 ,0x50 ,0x7 ,0xC0 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x60 ,0x7C ,0x0 ,0x1 ,0x81 ,0xFF ,0xFE ,0x38 ,0x3F ,0xF0 ,0x1 ,0xEF ,0x12 ,0x90 ,0x3F ,0x0 ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0xE0 ,0x3C ,0x0 ,0x1 ,0x83 ,0xF8 ,0xFF ,0xF8 ,0x7F ,0xF8 ,0x1 ,0xE3 ,0xCD ,0x50 ,0xFE ,0x0 ,0x6 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1 ,0x81 ,0xDC ,0x0 ,0x1 ,0x87 ,0xF0 ,0x7F ,0x0 ,0xFF ,0xFC ,0x1 ,0xE0 ,0xE2 ,0x13 ,0x7C ,0x0 ,0x0 ,0xC1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3 ,0x81 ,0x8C ,0x0 ,0x1 ,0x87 ,0xE0 ,0x7F ,0x1 ,0xFF ,0xFE ,0x1 ,0xE0 ,0x38 ,0x92 ,0x70 ,0x0 ,0x0 ,0x19 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0x87 ,0x0 ,0x0 ,0x1 ,0xBF ,0xE3 ,0x7F ,0xE1 ,0xFF ,0xFE ,0x1 ,0xE0 ,0x1E ,0x52 ,0x20 ,0x0 ,0x0 ,0x7 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xF ,0x86 ,0x0 ,0x0 ,0x1 ,0xBF ,0xE7 ,0xBF ,0xE3 ,0xFC ,0xFF ,0x1 ,0xE0 ,0xF ,0x12 ,0xE0 ,0x0 ,0x0 ,0x9 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x1F ,0xFC ,0x0 ,0x0 ,0x1 ,0xBF ,0xC3 ,0x3F ,0xE3 ,0xF0 ,0xFF ,0x1 ,0x9C ,0x0 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xF8 ,0x0 ,0x0 ,0x1 ,0x87 ,0xE0 ,0x7F ,0x7 ,0xE0 ,0x7F ,0x81 ,0x9E ,0x0 ,0x7E ,0x8 ,0x0 ,0x0 ,0x61 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x0 ,0x1 ,0x83 ,0xF8 ,0x7F ,0xF ,0x80 ,0x3F ,0x81 ,0x87 ,0x80 ,0x18 ,0x4 ,0x0 ,0x0 ,0x81 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x1 ,0x83 ,0xFF ,0xFE ,0xF ,0x0 ,0x3F ,0xC1 ,0x81 ,0xC0 ,0x10 ,0x6 ,0x0 ,0x3 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0xC0 ,0x0 ,0x0 ,0x1 ,0x81 ,0xFF ,0xFE ,0xF ,0x0 ,0x3F ,0xC1 ,0x80 ,0xE0 ,0x10 ,0x39 ,0x0 ,0x4 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xFF ,0x80 ,0x0 ,0x0 ,0x1 ,0xF8 ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x38 ,0x10 ,0xC1 ,0xC0 ,0x18 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFF ,0x0 ,0x0 ,0x0 ,0x1 ,0xF0 ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x1C ,0x10 ,0x41 ,0xF8 ,0x38 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFE ,0x0 ,0x0 ,0x0 ,0x1 ,0xF8 ,0x70 ,0x70 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x3 ,0x90 ,0xE0 ,0xFF ,0xF4 ,0x1 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xFC ,0x0 ,0x0 ,0x0 ,0x1 ,0xFC ,0xF0 ,0x79 ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x1 ,0xD1 ,0xF0 ,0x3F ,0x81 ,0x81 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xF ,0xF8 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x77 ,0x8 ,0x1F ,0x0 ,0x41 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xF0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x7F ,0x8 ,0xE ,0x0 ,0x21 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xE0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xF0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x18 ,0x4 ,0x4 ,0x0 ,0x11 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xC0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x0 ,0x9 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x1E ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,0x2 ,0x0 ,0x0 ,0x5 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x3 ,0x8F ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x80 ,0x0 ,0xD ,0x8F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x40 ,0x0 ,0x71 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x20 ,0x1 ,0x81 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x10 ,0x6 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x8 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x4 ,0x18 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x81);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_configuracao3( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC0 ,0x0 ,0x3 ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xE0 ,0x0 ,0x2 ,0x7F ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xF0 ,0x0 ,0x4 ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xF8 ,0x0 ,0xE ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFC ,0x0 ,0x1F ,0xFF ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7F ,0xFE ,0x0 ,0x1F ,0xFF ,0xC1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFF ,0xFC ,0x0 ,0x3 ,0xFF ,0xC1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xDF ,0x8F ,0xFF ,0xFE ,0x7F ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xDF ,0xBF ,0xF9 ,0xFF ,0x3F ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x5E ,0x7F ,0x0 ,0xF ,0xC7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7E ,0x7F ,0x0 ,0x7 ,0xE7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3C ,0xFC ,0x0 ,0x3 ,0xF7 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x31 ,0xE1 ,0xFF ,0xF0 ,0xFE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF ,0x9F ,0xF9 ,0xFE ,0x3C ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0x9F ,0xF9 ,0xFF ,0xE ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x3F ,0xF9 ,0xFF ,0x86 ,0x1 ,0x80 ,0x0 ,0x7E ,0x0 ,0xFE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0x7F ,0xF9 ,0xE7 ,0xC7 ,0x1 ,0x80 ,0x0 ,0x7E ,0x0 ,0xFE ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0xFF ,0xF9 ,0xEF ,0xC7 ,0x1 ,0x80 ,0x0 ,0xE1 ,0x83 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3E ,0xFF ,0xF9 ,0xDF ,0xE7 ,0x1 ,0x80 ,0x0 ,0xE1 ,0x83 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3D ,0xFF ,0xFF ,0x9F ,0xF7 ,0x81 ,0x80 ,0xF ,0x0 ,0x64 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7B ,0xFF ,0xFF ,0x7F ,0xFB ,0xC1 ,0x80 ,0x3C ,0x0 ,0x18 ,0x0 ,0x1C ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x73 ,0xFF ,0xFE ,0x7F ,0xFB ,0xE1 ,0x80 ,0x3C ,0x0 ,0x18 ,0x0 ,0x1C ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0x7F ,0xF9 ,0xE1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFF ,0xFF ,0x19 ,0xE1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xF9 ,0xFE ,0x9 ,0xE1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xF9 ,0xFF ,0x19 ,0xE1 ,0xA0 ,0x7F ,0x80 ,0x0 ,0x7 ,0xFF ,0xF9 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0xA0 ,0x0 ,0x7F ,0xC1 ,0xFE ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xF3 ,0xFF ,0xFE ,0xFF ,0xF9 ,0xE1 ,0xA0 ,0x0 ,0x7F ,0xC1 ,0xFE ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFB ,0xFF ,0xFE ,0x7F ,0xF9 ,0xE1 ,0x98 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0xFD ,0xFF ,0xFF ,0x7F ,0xFB ,0xE1 ,0x98 ,0x0 ,0x0 ,0xFF ,0x80 ,0x0 ,0x19 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7D ,0xFF ,0xFF ,0x3F ,0xFB ,0xE1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0xFF ,0xFF ,0x3F ,0xFB ,0xE1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7C ,0x7F ,0xFF ,0xDF ,0xF7 ,0xC1 ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x7F ,0xFC ,0xFF ,0xE7 ,0x81 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x3F ,0xFC ,0xFF ,0xC7 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xBF ,0xFC ,0xFF ,0x8F ,0x1 ,0x80 ,0x3C ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0xBF ,0xFC ,0xFF ,0x1F ,0x1 ,0x80 ,0x3C ,0x0 ,0x0 ,0x0 ,0xC ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x9F ,0xFD ,0xFE ,0x3E ,0x1 ,0x80 ,0xF ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1F ,0xC1 ,0xFF ,0xFC ,0x78 ,0x1 ,0x80 ,0xF ,0x0 ,0x0 ,0x0 ,0x70 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xFC ,0x0 ,0x1 ,0xF8 ,0x1 ,0x80 ,0x0 ,0xE0 ,0x0 ,0x7 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xFF ,0x0 ,0x7 ,0xF8 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1E ,0xFF ,0xE0 ,0xFF ,0xC6 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x3F ,0x7F ,0xFF ,0xFF ,0x8E ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x3F ,0x7F ,0xFF ,0xFF ,0x8E ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x3E ,0x3F ,0xFF ,0xFC ,0xE ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x3C ,0xF ,0xFF ,0xFC ,0x6 ,0x1 ,0x93 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8F ,0x0 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x95 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x99 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0x9, "CONFIGURA", sizeof("CONFIGURA"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x81);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_servicos1( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0x1F ,0x80 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xC0 ,0x0 ,0xF8 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3C ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x80 ,0x1C ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0x0 ,0x0 ,0x4C ,0x0 ,0x1 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x80 ,0x1F ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x6 ,0x3 ,0xFC ,0x64 ,0x0 ,0x1 ,0x81 ,0x50 ,0x0 ,0x0 ,0x0 ,0x0 ,0x41 ,0x80 ,0x7 ,0xE0 ,0x0 ,0x7C ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0xFF ,0xFE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0xC ,0xF ,0xFE ,0x3A ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x2 ,0x81 ,0x80 ,0x0 ,0xF0 ,0x0 ,0x3F ,0x0 ,0x1 ,0x80 ,0x0 ,0x7 ,0xFF ,0xFF ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x3F ,0xFF ,0xE ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x3 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3F ,0xEE ,0x3F ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x70 ,0xF ,0x85 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0xF ,0x81 ,0x80 ,0x3 ,0xE0 ,0x0 ,0x1 ,0xE0 ,0x1 ,0x80 ,0x0 ,0xFF ,0xFF ,0xF8 ,0x7C ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x20 ,0x1F ,0x1 ,0xE3 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x80 ,0xF ,0x60 ,0x0 ,0x0 ,0x70 ,0x1 ,0x80 ,0x7 ,0xBF ,0xFF ,0xFF ,0xF7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x7F ,0xE0 ,0xE3 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0xA ,0x1 ,0x80 ,0x1E ,0x60 ,0x0 ,0x0 ,0x38 ,0x1 ,0x80 ,0xF ,0x7F ,0xFF ,0xFF ,0xFF ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x7F ,0xE0 ,0x73 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x10 ,0x1 ,0x80 ,0x38 ,0x60 ,0x0 ,0x0 ,0x18 ,0x1 ,0x80 ,0x1C ,0xC3 ,0xFF ,0xFF ,0xFB ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x80 ,0xF8 ,0x73 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x20 ,0x1 ,0x80 ,0x30 ,0x60 ,0x0 ,0x0 ,0x1C ,0x1 ,0x80 ,0x3B ,0x87 ,0xFF ,0xFF ,0xFD ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0xE1 ,0x0 ,0x1C ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x40 ,0x1 ,0x80 ,0x70 ,0x60 ,0x0 ,0x0 ,0xE ,0x1 ,0x80 ,0x77 ,0xBF ,0xFF ,0xF8 ,0x3E ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0xE ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x80 ,0x1 ,0x80 ,0xE0 ,0x60 ,0x0 ,0x0 ,0x7 ,0x1 ,0x80 ,0xEF ,0xFF ,0xFF ,0xE3 ,0x9E ,0x71 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x6 ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x1 ,0x0 ,0x1 ,0x80 ,0xC0 ,0x60 ,0x0 ,0x0 ,0x3 ,0x1 ,0x81 ,0xDF ,0xFF ,0xFF ,0xE3 ,0x9F ,0x79 ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x33 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x2 ,0x0 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x0 ,0x3 ,0x81 ,0x87 ,0x3F ,0xFF ,0xE0 ,0xF3 ,0x9F ,0xDD ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0xD0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x4 ,0x0 ,0x1 ,0x83 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x8E ,0x7F ,0xFF ,0x86 ,0x70 ,0x3F ,0xDF ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0x90 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x8 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x9C ,0xFF ,0xFC ,0x9E ,0x38 ,0xFF ,0xEF ,0x0 ,
			0x0 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x23 ,0xB0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x10 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0x9B ,0xFF ,0xE0 ,0x1F ,0x38 ,0xFF ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x0 ,0x0 ,0x3 ,0xB0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x20 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xB7 ,0xFF ,0x83 ,0x1F ,0x3C ,0x7F ,0xFF ,0x0 ,
			0x0 ,0x80 ,0x60 ,0x0 ,0x0 ,0x3 ,0x20 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x40 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xB7 ,0xE3 ,0xA7 ,0x1F ,0x9C ,0x7F ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x30 ,0x0 ,0x0 ,0x3 ,0x20 ,0x1 ,0x80 ,0x40 ,0x0 ,0x0 ,0x80 ,0x0 ,0x1 ,0x87 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xB7 ,0xC1 ,0xE7 ,0x9F ,0x9C ,0x3F ,0xEF ,0x0 ,
			0x0 ,0x80 ,0x1C ,0x0 ,0x0 ,0xC ,0x60 ,0x1 ,0x80 ,0x40 ,0x0 ,0x1 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xA7 ,0x9F ,0xF3 ,0x8F ,0x1E ,0x7F ,0xDD ,0x0 ,
			0x0 ,0x80 ,0x3E ,0x0 ,0x0 ,0x1C ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x2 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0x9F ,0xF3 ,0xC6 ,0x3F ,0xFF ,0xBD ,0x0 ,
			0x0 ,0x80 ,0x2F ,0x0 ,0x0 ,0x3C ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x4 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xC1 ,0xF3 ,0xC0 ,0x3F ,0xFF ,0xB9 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0xC0 ,0x0 ,0x71 ,0xC0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x8 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xE0 ,0xF1 ,0xE0 ,0xFF ,0xFF ,0x39 ,0x0 ,
			0x0 ,0x80 ,0x11 ,0xF0 ,0x1 ,0xE3 ,0x80 ,0x1 ,0x80 ,0x40 ,0x0 ,0x10 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xF9 ,0xFF ,0xFF ,0xCF ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x7E ,0x3 ,0x83 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x20 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xF9 ,0xFF ,0xFF ,0xCE ,0x71 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x3F ,0xFE ,0xFE ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x40 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x61 ,0xE7 ,0xFC ,0xFF ,0xFF ,0xFF ,0xDE ,0xF1 ,0x0 ,
			0x0 ,0x80 ,0x3 ,0xC0 ,0x1 ,0x8 ,0x0 ,0x1 ,0x80 ,0x40 ,0x0 ,0x80 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xE1 ,0xF7 ,0x0 ,0xFF ,0xFF ,0xFF ,0x9D ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xE0 ,0x1 ,0x4 ,0x0 ,0x1 ,0x80 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0x80 ,0xFF ,0xFF ,0xFF ,0x1B ,0xE1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x3F ,0xFF ,0x0 ,0x0 ,0x1 ,0x80 ,0x40 ,0x2 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xC3 ,0xFF ,0xFF ,0xFC ,0x1B ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x7 ,0xFE ,0x2 ,0x0 ,0x1 ,0x80 ,0x40 ,0x4 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFC ,0x3F ,0xC1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x83 ,0x0 ,0x1 ,0x80 ,0x40 ,0x8 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFC ,0x77 ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x83 ,0x80 ,0x1 ,0x80 ,0x40 ,0x10 ,0x0 ,0x0 ,0x0 ,0x1 ,0x83 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC1 ,0xF7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xF7 ,0x81 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x41 ,0x80 ,0x1 ,0x80 ,0x40 ,0x20 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0xC0 ,0x0 ,0x0 ,0x6 ,0x3 ,0x81 ,0xB3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xC7 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x20 ,0xE0 ,0x1 ,0x80 ,0x42 ,0x40 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xC0 ,0x0 ,0x0 ,0x6 ,0x3 ,0x1 ,0xBE ,0x7F ,0xFF ,0xFF ,0xFC ,0x7E ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x20 ,0xF0 ,0x1 ,0x80 ,0x42 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xE0 ,0x0 ,0x0 ,0x6 ,0x7 ,0x1 ,0x9F ,0x3F ,0xFF ,0xFF ,0xF1 ,0xFC ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x30 ,0x70 ,0x1 ,0x80 ,0x43 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x70 ,0x0 ,0x0 ,0x6 ,0xE ,0x1 ,0x8F ,0xCF ,0xFF ,0xFF ,0x87 ,0xF8 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x10 ,0x38 ,0x1 ,0x80 ,0x4F ,0x80 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x38 ,0x0 ,0x0 ,0x6 ,0x1C ,0x1 ,0x87 ,0xE3 ,0xFF ,0xFE ,0x3F ,0xF0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x10 ,0x38 ,0x1 ,0x80 ,0x46 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x18 ,0x0 ,0x0 ,0x6 ,0x78 ,0x1 ,0x81 ,0xF8 ,0xFF ,0xF0 ,0xFF ,0xC0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x18 ,0x18 ,0x1 ,0x80 ,0x4A ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1C ,0x0 ,0x0 ,0x6 ,0xF0 ,0x1 ,0x80 ,0xFE ,0x7F ,0xC3 ,0xFE ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x18 ,0xC ,0x1 ,0x80 ,0x50 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0xE ,0x0 ,0x0 ,0x7 ,0xC0 ,0x1 ,0x80 ,0x3F ,0x9F ,0x1F ,0xF8 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x4 ,0xC7 ,0x1 ,0x80 ,0x60 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x80 ,0x7 ,0x80 ,0x0 ,0xF ,0x80 ,0x1 ,0x80 ,0x7 ,0xF3 ,0xFE ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x83 ,0x81 ,0x80 ,0x40 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x80 ,0x1 ,0xC0 ,0x0 ,0xF ,0x0 ,0x1 ,0x80 ,0x1 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x7 ,0x1 ,0x81 ,0x80 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xF9 ,0x80 ,0x0 ,0xFC ,0x0 ,0x7 ,0xE0 ,0x1 ,0x80 ,0x0 ,0xFF ,0x80 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x2 ,0x3E ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x11 ,0x9F ,0x0 ,0x3E ,0x0 ,0x1 ,0xF8 ,0x1 ,0x82 ,0x0 ,0x3C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8C ,0x0 ,0x0 ,0x0 ,0x2 ,0x66 ,0x41 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x21 ,0x82 ,0x0 ,0x2 ,0x0 ,0x0 ,0x38 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x2 ,0xC0 ,0x41 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8A ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0xC1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x92 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x3 ,0x83 ,0x81 ,0x84 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x84 ,0x0 ,0x0 ,0x0 ,0x1 ,0xC7 ,0x81 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x1 ,0xFF ,0x1 ,0x9F ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0xB, "SERVI", sizeof("SERVI"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_servicos2( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xF ,0xFF ,0xE0 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1F ,0xFF ,0xF8 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0xFC ,0x3 ,0xFE ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xF0 ,0x0 ,0xF ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0xC0 ,0x0 ,0x7 ,0x60 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x3 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0x80 ,0x0 ,0xF3 ,0xE0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xE ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0xFF ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x38 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x1F ,0xC0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1 ,0xC0 ,0x40 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x1E ,0x20 ,0x20 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x78 ,0x30 ,0x20 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0x0 ,0x0 ,0x0 ,0x6 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x1 ,0xC0 ,0x30 ,0x30 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x7 ,0x0 ,0x0 ,0x0 ,0x1C ,0x1 ,0x80 ,0x7F ,0xFF ,0xC0 ,0x1F ,0xFF ,0xF1 ,0x80 ,0x0 ,0xF ,0x0 ,0x10 ,0x10 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0xC0 ,0x0 ,0x0 ,0x30 ,0x1 ,0x81 ,0x80 ,0x0 ,0xC0 ,0x60 ,0x0 ,0x31 ,0x80 ,0x0 ,0x78 ,0x0 ,0x18 ,0x10 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x60 ,0x0 ,0x0 ,0xC0 ,0x1 ,0x86 ,0x0 ,0x1 ,0x41 ,0x80 ,0x0 ,0x51 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x18 ,0x18 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x38 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x3B ,0x80 ,0x0 ,0x8 ,0x8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x44 ,0x0 ,0x6 ,0x40 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0x4C ,0xFC ,0x0 ,0xC ,0x8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x42 ,0x0 ,0x8 ,0x40 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0x4C ,0x4 ,0x0 ,0x4 ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0xC7 ,0x80 ,0x8 ,0x20 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x80 ,0xC4 ,0x4 ,0x0 ,0x4 ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x84 ,0xF0 ,0x7C ,0x30 ,0x1 ,0x8B ,0xBB ,0xBA ,0x42 ,0xEE ,0xEE ,0x91 ,0x80 ,0x86 ,0x46 ,0x0 ,0xC ,0x4 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x8C ,0xF ,0xC6 ,0x10 ,0x1 ,0x8A ,0xAA ,0xAA ,0x42 ,0xAA ,0xAA ,0x91 ,0x81 ,0x86 ,0x42 ,0x0 ,0x38 ,0x6 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x8 ,0xE ,0x2 ,0x18 ,0x1 ,0x8B ,0xBB ,0xBA ,0x42 ,0xEE ,0xEE ,0x91 ,0x81 ,0x82 ,0x62 ,0x0 ,0xF8 ,0x2 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x8 ,0x30 ,0x2 ,0x8 ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x83 ,0x3 ,0x63 ,0x3 ,0xC0 ,0x2 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x10 ,0x60 ,0x1 ,0xC ,0x1 ,0x88 ,0x0 ,0x2 ,0x42 ,0x0 ,0x0 ,0x91 ,0x81 ,0x1 ,0x38 ,0x7C ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x10 ,0x80 ,0x1 ,0x84 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x81 ,0x81 ,0x81 ,0xE0 ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x31 ,0x0 ,0x0 ,0x82 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x81 ,0x81 ,0x87 ,0x7 ,0x0 ,0x1 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x21 ,0x40 ,0x0 ,0xC3 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x81 ,0xFC ,0x1F ,0xC0 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x61 ,0x40 ,0x0 ,0x41 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC0 ,0xF8 ,0x38 ,0xE0 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x8 ,0x41 ,0x1 ,0xC0 ,0x61 ,0x81 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC0 ,0x0 ,0x60 ,0x30 ,0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x18 ,0xC0 ,0xFE ,0x30 ,0x30 ,0xC1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x40 ,0x0 ,0xC0 ,0x18 ,0x0 ,0xC1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x10 ,0x80 ,0x0 ,0x8 ,0x10 ,0x41 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x0 ,0x0 ,0x82 ,0x18 ,0x0 ,0x41 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x30 ,0x80 ,0x0 ,0x6 ,0x8 ,0x61 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x20 ,0x0 ,0x82 ,0x8 ,0x0 ,0x61 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8C ,0x21 ,0x0 ,0x0 ,0x1 ,0xC ,0x31 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x20 ,0x0 ,0x80 ,0x8 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x61 ,0x0 ,0x0 ,0x0 ,0x86 ,0x11 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0x80 ,0x18 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x42 ,0x0 ,0x0 ,0x80 ,0x43 ,0x19 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0x80 ,0x18 ,0x0 ,0x31 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xC0 ,0x86 ,0x0 ,0x0 ,0xE0 ,0x33 ,0xFF ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x30 ,0x0 ,0xC0 ,0x30 ,0x0 ,0x11 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xF8 ,0xC6 ,0x0 ,0x0 ,0x38 ,0x17 ,0xE7 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x18 ,0x0 ,0x60 ,0x60 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9F ,0xF9 ,0x0 ,0x0 ,0xE ,0x1C ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0xF ,0x0 ,0x0 ,0x9 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0xB ,0x9C ,0x3 ,0x1 ,0xF0 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x61 ,0x80 ,0xC0 ,0x60 ,0x1 ,0x88 ,0x0 ,0x2 ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0xC ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x22 ,0x40 ,0x38 ,0x60 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x6 ,0x0 ,0x0 ,0x0 ,0x0 ,0xD ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x22 ,0x6 ,0x7 ,0xC0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x43 ,0xFF ,0xFF ,0x91 ,0x80 ,0x6 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3D ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x4 ,0x62 ,0x23 ,0x82 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x83 ,0xFF ,0xFF ,0xA1 ,0x80 ,0x2 ,0x0 ,0x0 ,0x0 ,0x1 ,0xF1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x2 ,0x62 ,0x48 ,0x3E ,0x0 ,0x1 ,0x8F ,0xFF ,0xFF ,0x3 ,0xFF ,0xFF ,0xC1 ,0x80 ,0x3 ,0x0 ,0x0 ,0x0 ,0x7 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x1 ,0x9E ,0x4 ,0x30 ,0x0 ,0x1 ,0x8F ,0xFF ,0xFE ,0x3 ,0xFF ,0xFF ,0x81 ,0x80 ,0x1 ,0x0 ,0x0 ,0x0 ,0xF8 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x80 ,0x0 ,0x0 ,0x43 ,0xE0 ,0x0 ,0x1 ,0x80 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x80 ,0x1 ,0x80 ,0x0 ,0x3 ,0xC0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9F ,0x0 ,0x0 ,0xE6 ,0x0 ,0x0 ,0x1 ,0x86 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9F ,0x1 ,0x80 ,0x0 ,0xF ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x88 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x81 ,0x0 ,0x80 ,0x0 ,0x7C ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x90 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x82 ,0x0 ,0x80 ,0x1 ,0xE0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x9E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x98 ,0x1F ,0x80 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x81 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x43 ,0xC0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x91 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x67 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x8E ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x84 ,0x0 ,0x7C ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
			0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,

	};
	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto(0xB, "SERVI", sizeof("SERVI"));
	send_data(0x60);
	send_command(0xC0);
	status(1);
	send_data(0x2F);
	send_command(0xC0);
	status(1);

}

void desenho_inicializacao( void ){

	unsigned int addr = 0x780;
	unsigned char desenho[] = {
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xE0 ,0xFF ,0xFF ,0xFF ,0xF8 ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xC0 ,0xFF ,0xFF ,0xFF ,0xFC ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xFF ,0xFE ,0xF ,0xFF ,0xFC ,0x1 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC3 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFF ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC7 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xC7 ,0xFF ,0xFF ,0xFF ,0xFE ,0x1F ,0xFF ,0xFC ,0x3 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFF ,0x1F ,0xFF ,0xFE ,0x7 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFE ,0x1F ,0xFF ,0xFE ,0x7 ,0xFE ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x1F ,0xC0 ,0x0 ,0xFF ,0x0 ,0xF ,0xF0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x80 ,0x3F ,0xFE ,0x1F ,0xFF ,0xFF ,0x7 ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x1F ,0xC0 ,0x0 ,0xFF ,0x0 ,0x1F ,0xF0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x0 ,0x7F ,0xFE ,0x1F ,0xFF ,0xFF ,0xF ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x3F ,0xE0 ,0x0 ,0xFF ,0x80 ,0x1F ,0xE0 ,0x0 ,0xF ,0xFF ,0x8F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0xF ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xC0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x7F ,0x80 ,0x1F ,0xC0 ,0x0 ,0xF ,0xFF ,0x9F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x1 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x3F ,0xC0 ,0x3F ,0x80 ,0x0 ,0xF ,0xFF ,0x9F ,0xFF ,0x0 ,0x7F ,0xFE ,0x3F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x1 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x1F ,0xE0 ,0x7F ,0x80 ,0x0 ,0xF ,0xFF ,0x1F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0x7F ,0xF0 ,0x0 ,0x1F ,0xE0 ,0xFF ,0x80 ,0x0 ,0x1F ,0xFF ,0x1F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xE0 ,0x3 ,0xFF ,0xE0 ,0x0 ,0xFF ,0xF0 ,0x0 ,0x1F ,0xF0 ,0xFF ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0x7F ,0xFE ,0x7F ,0xFF ,0xFF ,0x8F ,0xFC ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x0 ,0xFD ,0xF8 ,0x0 ,0xF ,0xF0 ,0xFE ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0x7F ,0xFC ,0x7F ,0xFF ,0xFF ,0x9F ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x1 ,0xFD ,0xFC ,0x0 ,0x7 ,0xF8 ,0xFC ,0x0 ,0x0 ,0x1F ,0xFF ,0x3F ,0xFE ,0x0 ,0xFF ,0xFC ,0x7F ,0xF7 ,0xFF ,0xDF ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFF ,0xF0 ,0x3 ,0xEF ,0xE0 ,0x1 ,0xFD ,0xFC ,0x0 ,0x3 ,0xF9 ,0xFC ,0x0 ,0x0 ,0x1F ,0xFE ,0x3F ,0xFC ,0x0 ,0xFF ,0xFC ,0x7F ,0xE7 ,0xFF ,0xDF ,0xF8 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFD ,0xF8 ,0x7 ,0xEF ,0xE0 ,0x3 ,0xF8 ,0xFC ,0x0 ,0x3 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x3F ,0xFE ,0x7F ,0xFC ,0x0 ,0xFF ,0xFC ,0x7F ,0xE7 ,0xFF ,0xDF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFD ,0xF8 ,0x7 ,0xEF ,0xE0 ,0x3 ,0xF8 ,0xFC ,0x0 ,0x3 ,0xFF ,0xF0 ,0x0 ,0x0 ,0x3F ,0xFE ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xE3 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0xF ,0xCF ,0xE0 ,0x7 ,0xF0 ,0xFE ,0x0 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x3F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC3 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0xF ,0x8F ,0xE0 ,0x7 ,0xF0 ,0xFF ,0x0 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0x1F ,0x8F ,0xE0 ,0x7 ,0xE0 ,0xFF ,0x0 ,0x0 ,0x7F ,0xC0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x0 ,0xFF ,0xF8 ,0xFF ,0xC1 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFC ,0x1F ,0xF ,0xE0 ,0xF ,0xE0 ,0x7F ,0x80 ,0x0 ,0x7F ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xFC ,0x1 ,0xFF ,0xF0 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFE ,0x1F ,0xF ,0xE0 ,0x1F ,0xE0 ,0x7F ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xF8 ,0x1 ,0xFF ,0xF0 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xFE ,0x1F ,0xF ,0xE0 ,0x1F ,0xE0 ,0x3F ,0x80 ,0x0 ,0xFF ,0xE0 ,0x0 ,0x0 ,0x7F ,0xFC ,0x7F ,0xF8 ,0x1 ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xF0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7F ,0x3F ,0xF ,0xE0 ,0x1F ,0xC0 ,0x3F ,0xC0 ,0x3 ,0xFF ,0xF0 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xF9 ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7F ,0x3F ,0xF ,0xE0 ,0x1F ,0xFF ,0xFF ,0xC0 ,0x3 ,0xFF ,0xF8 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF1 ,0xFF ,0x81 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3F ,0x7F ,0xF ,0xE0 ,0x3F ,0xFF ,0xFF ,0xE0 ,0x3 ,0xFB ,0xFC ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x80 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3F ,0x7F ,0xF ,0xE0 ,0x3F ,0xFF ,0xFF ,0xE0 ,0x7 ,0xF1 ,0xFC ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x0 ,0xFF ,0xFF ,0xE0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0x7E ,0xF ,0xE0 ,0x7F ,0xFF ,0xFF ,0xE0 ,0xF ,0xF0 ,0xFE ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xE1 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFE ,0xF ,0xE0 ,0x7F ,0xFF ,0xFF ,0xE0 ,0x1F ,0xF0 ,0xFF ,0x0 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x81 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFC ,0xF ,0xE0 ,0xFF ,0x80 ,0xF ,0xF0 ,0x1F ,0xE0 ,0xFF ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xF3 ,0xFF ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x1F ,0xFC ,0xF ,0xE0 ,0xFF ,0x0 ,0xF ,0xF0 ,0x1F ,0xC0 ,0xFF ,0x80 ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFE ,0x0 ,0xFF ,0xFF ,0xC0 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xF ,0xFC ,0xF ,0xE0 ,0xFE ,0x0 ,0x7 ,0xF8 ,0x7F ,0x80 ,0x7F ,0x80 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0xF ,0xFC ,0xF ,0xE0 ,0xFE ,0x0 ,0x3 ,0xF8 ,0x7F ,0x80 ,0x3F ,0xC0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x3 ,0xFC ,0xFF ,0x0 ,0x1F ,0xF0 ,0x1 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x7 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x3 ,0xFC ,0xFE ,0x0 ,0x1F ,0xF0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x1 ,0xFC ,0x3 ,0xF8 ,0xF ,0xE1 ,0xFC ,0x0 ,0x1 ,0xFC ,0xFE ,0x0 ,0xF ,0xF0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x80 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0xFC ,0x0 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xFF ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0xF ,0xF0 ,0x0 ,0x0 ,0x0 ,0x7F ,0xFF ,0xFF ,0xFF ,0x87 ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xFF ,0xFF ,0xFC ,0x0 ,0xFF ,0xFF ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7F ,0xFF ,0x80 ,0x0 ,0x1F ,0xFE ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1F ,0xFE ,0x0 ,0x0 ,0x3 ,0xFE ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x7 ,0xF8 ,0x0 ,0x0 ,0x0 ,0x7E ,0x0 ,0x0 ,0x0 ,
			0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x3 ,0xE0 ,0x0 ,0x0 ,0x0 ,0x3C ,0x0 ,0x0 ,0x0 ,


	};

	send_data(addr & 0xFF);
	send_data(addr >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i <1680; i++  ){
		send_data(desenho[i]);
	}
	send_command(Auto_reset);
	status(2);

	escrita_texto( 0x16A, "Analisador de eletrolitos", sizeof("Analisador de eletrolitos"));

	escrita_texto( 0x1A9, "WWW.MEDMAXNET.COM.BR", sizeof("WWW.MEDMAXNET.COM.BR"));

}


void escrita_texto( unsigned int posicao, char *texto, unsigned char tamanho ){


	send_data(posicao & 0xFF);
	send_data(posicao >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( int i = 0; i < tamanho - 1; i++ ){
		send_data(*(texto++) - 0x20);
	}

	send_command(Auto_reset);
	status(2);

}

void clear_display_text( void ){

	send_data(0x00);
	send_data(0x00);
	send_command(Set_address_pointer);

	send_command(Display_mode_text);

	send_command(Set_data_auto_write);
	status(2);

	for( int i = 0; i < 480; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

}

unsigned char calibA( unsigned char wash ){

	// Declaraçõe de variáveis
	unsigned char sample = 0, estado = 0, texto = 0, segundos = 30, erroDiferencaTensoes = 0, flagSegundo = 0;
	unsigned int  temporizador = 1000, contError = 0, contReadAD = 0;
	unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	unsigned int medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned int medidasCalibSalva[6] = {0,0,0,0,0,0};
	unsigned char contAddrMemoria = 80, contadorCalib = 1, hora, minuto;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;

	for( unsigned int i = ADDR_FLASH + 0x768; i >= ADDR_FLASH; i = i - DADOS_SALVOS ){	// Faz a verificação de memória apagada

		if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
			// Armazena no vetor os valores de calibração já feitos
			medidaCalAnterior_K = *(volatile unsigned short *)(i);
			medidaCalAnterior_Na = *(volatile unsigned short *)(i + DADO_MEMORIA);
			medidaCalAnterior_Cl = *(volatile unsigned short *)(i + DADO_MEMORIA * 2);
			medidaCalAnterior_Ca = *(volatile unsigned short *)(i + DADO_MEMORIA * 3);
			medidaCalAnterior_pH = *(volatile unsigned short *)(i + DADO_MEMORIA * 4);
			break;
		}
		contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

	}

	writeLine(13);	// Escreve o desenho da linha de separação na tela

	if( !wash ){	// Se wash (lavando) igual a 0
		escrita_texto( 9, "Calibrador A", sizeof("Calibrador A"));	// Escreve Calibrador A na posição 9
		escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
	}
	else
		escrita_texto( 400, "Lavando...", sizeof("Lavando..."));	// Escreve "Lavando..." na posição 400

	while( 1 ){		// Enquanto

		switch( estado ){

		case 0:	// Estado 0, movimento dos motores

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 250ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, TIMER1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, TIMER2);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, PULSE_TM);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 250ms movimento rápido
			sample = move_tripa(WAYHOUR, SPEEDTRP3, TIMER1);

			// Movimenta anti horário em 2500ms movimento rápido
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, TIMER3);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 2
			move_mux(POSITION2, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 838ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1500);
			vTaskDelay(TIMERCOM);

			// Move motor MUX para posição 1
			move_mux(POSITION1, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 15 segundos
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, END_TM2);

			if( sample == 0 && contError < 2 )	// Se não detectou líquido e a contagem de error menor que 2
				contError++; // Incrementa contagem de erro

			else if( contError == 2 ){	// Senão se contagem de erro igual a 2

				// Escreve "Falta Calibrador A. Aspirar novamente?" na posição 210
				escrita_texto(210, "Falta Calibrador A. Aspirar novamente?", sizeof("Falta Calibrador A. Aspirar novamente?"));
				escrita_texto(450, "YES=Asp NO=Sair 1=Help", sizeof("YES=Asp NO=Sair 1=Help"));	// Escreve "YES=Asp NO=Sair 1=Help" na posição 450
				estado = 1;	// Estado recebe 1, não detectou líquido
				contError = 0;	// Contagem de erro recebe 0

			}
			else{	// Senão, para a detecção de líquido

				estado = 2;	// Estado recebe 2, mede a tensão dos eletrodos
				contError = 0;	// Contagem de erro recebe 0
				if( wash )
					return 0;
				else{
					writeLine(13);
					escrita_texto( 401, "Testando", sizeof("Testando") );
					vTaskDelay(10000);	// Delay de 10 segundos
					segundos = 30;
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos
				}
			}
			break;

		case 1:

			if( verifyKeyBoard() == yes ){	// Se teclado igual a Yes
				estado = 0;	// Estado recebe 0, inicialização e movimento dos motores
				clear_display_text();
				writeLine(13);	// Escreve o desenho da linha de separação na tela

				if( !wash ){	// Se wash (lavando) igual a 0
					escrita_texto( 9, "Calibrador A", sizeof("Calibrador A"));	// Escreve Calibrador A na posição 9
					escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else
					escrita_texto( 400, "Lavando...", sizeof("Lavando..."));	// Escreve "Lavando..." na posição 400
			}
			else if( verifyKeyBoard() == no )	// Senão se teclado igual a No
				return ERRO;	// Retorna 2

			else if( verifyKeyBoard() == um ){	// Senão se teclado igual a 1

				clearLine(10);	// Limpa a linha 10
				clearLine(11);	// Limpa a linha 11
				clearLine(12);	// Limpa a linha 12
				if( texto == 0 ) // Se se texto igual a 0
					escrita_texto(300, "Verificar a disponibilidade", sizeof("Verificar a disponibilidade"));// Escreve "Verificar a disponibilidade" na posição 330

				else if( texto == 1 )	// Senão se texto igual a 1
					// Escreve "Se a bomba estiver c/ aderencia um som diferente será ouvido"
					escrita_texto(300, "Se a bomba estiver c/ aderencia um som diferente vai ser ouvido", sizeof("Se a bomba estiver c/ aderencia um som diferente vai ser ouvido"));

				else if( texto == 2 )	// Senão se texto igual a 2
					// Escreve "O mau estado dos conectores e anéis de vedação"
					escrita_texto(300, "O mau estado dos conectores e aneis de vedacao", sizeof("O mau estado dos conectores e aneis de vedacao"));

				else if( texto == 3 )// Senão se texto igual a 3
					escrita_texto(300, "A tubulacao c/ entupimento", sizeof("A tubulacao c/ entupimento"));	// Escreve "A tubulação c/ entupimento"

				else	// Senão se texto igual a 4
					// Escreve "Favor ir para MULTIPLEXER CHECK(checar Multiplexador)"
					escrita_texto(300, "Favor ir em MULTIPLEXER CHECK (checar Multiplexador)", sizeof("Favor ir em MULTIPLEXER CHECK(checar Multiplexador)"));

				texto++;	// Texto incrementa
				if( texto == 5 )	// Se texto igual a 5
					texto = 0;	// Texto recebe 0
			}

			break;

		case 2:

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador

					escrita_texto(92, "K  =   4.00 mmol/L  ", sizeof( "K  =   4.00 mmol/L  "));
					escrita_texto(112, numtolcd(voltageCalA_K, CAL), 7);
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na  = 140.00 mmol/L  ", sizeof("Na  = 140.00 mmol/L  "));
					escrita_texto(172, numtolcd(voltageCalA_Na, CAL), 7);
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl  = 100.00 mmol/L  ", sizeof("Cl  = 100.00 mmol/L  "));
					escrita_texto(232, numtolcd(voltageCalA_Cl, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca  =   1.25 mmol/L  ", sizeof("Ca  =   1.25 mmol/L  "));
					escrita_texto(292, numtolcd(voltageCalA_Ca, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH  =   7.40         ", sizeof("pH  =   7.40         "));
					escrita_texto(352, numtolcd(voltageCalA_pH, CAL), 7);
					escrita_texto(358, "mV", sizeof( "mV"));

					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos
					segundos--; // Decrementa segundos
					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 3;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 1750 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{	// Senão
					voltageCalA_K =	k * 8.0325 / contReadAD;	// Calcula a tensão para k. Medida atual
					voltageCalA_pH = ph * 8.0325 / contReadAD;	// Calcula a tensão para ph. Medida atual
					voltageCalA_Ca = ca * 8.0325 / contReadAD;	// Calcula a tensão para ca. Medida atual
					voltageCalA_Cl = cl * 8.0325 / contReadAD;	// Calcula a tensão para cl. Medida atual
					voltageCalA_Na = na * 8.0325 / contReadAD;	// Calcula a tensão para na. Medida atual
					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;

					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - voltageCalA_K) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - voltageCalA_Na) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - voltageCalA_Cl) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - voltageCalA_Ca) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - voltageCalA_pH) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);

						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}

					if( erroDiferencaTensoes == 0 && segundos < 27 ){	// Se diferença for menor que 500 e segundo menor que 27

						I2C_READ_PCF8653( &hora, Hours ) ;	// Medida de hora do RTC
						I2C_READ_PCF8653( &minuto, Minutes );	// Medida de minuto do RTC
						medidasCalibSalva[0] = voltageCalA_K;	// Salva calibrador K
						medidasCalibSalva[1] = voltageCalA_Na;	// Salva calibrador Na
						medidasCalibSalva[2] = voltageCalA_Cl;	// Salva calibrador Cl
						medidasCalibSalva[3] = voltageCalA_Ca;	// Salva calibrador Ca
						medidasCalibSalva[4] = voltageCalA_pH;	// Salva calibrador pH
						medidasCalibSalva[5] = bcdtodec(hora & 0x3F) << 16 | bcdtodec(minuto & 0x7F) << 8 | contadorCalib;	// Salva horário, contador de calibração e 0 para calibrador A
						FLASH_Program(&s_flashDriver, ADDR_FLASH + contAddrMemoria * DADOS_SALVOS, medidasCalibSalva, DADOS_SALVOS);	// Salva dados de calibração

						contAddrMemoria++;	// Incrementa contador de memória

						if( abs(medidaCalAnterior_K - voltageCalA_K) > 500 ||
								abs(medidaCalAnterior_Na - voltageCalA_Na) > 500 ||
								abs(medidaCalAnterior_Cl - voltageCalA_Cl) > 500 ||
								abs(medidaCalAnterior_Ca - voltageCalA_Ca) > 500 ||
								abs(medidaCalAnterior_pH - voltageCalA_pH) > 500 ){
							contadorCalib++;
							if( contadorCalib > 3 )
								estado = 3;
							else{
								clearLine(3);
								clearLine(5);
								clearLine(7);
								clearLine(9);
								clearLine(11);
								escrita_texto(28, "  ", sizeof("  "));
								escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
								estado = 0;
							}
						}
						else{
							estado = 3;
						}
						if( estado != 3 ){
							medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS);	// Lê o valor de calibração anterior K
							medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
							medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
							medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
							medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH
						}
					}
					else if( erroDiferencaTensoes != 0 && segundos == 0 ){	// Senão

						estado = 0;			// Estado recebe 0
						contError++;				// contErro incrementa
						if( contError == 2 ){	// Se contErro igual a 2
							estado = 3;			// Estado recebe 3 (Verificação de erros)
							contError = 0;		// Zera contador de erro
							escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
						}

					}
					contReadAD = 0;	// Zera contador de leitura AD

					// Medida anterior recebe Medida atual
					medidaAnterior_K = voltageCalA_K;
					medidaAnterior_Na = voltageCalA_Na;
					medidaAnterior_Ca = voltageCalA_Ca;
					medidaAnterior_Cl = voltageCalA_Cl;
					medidaAnterior_pH = voltageCalA_pH;


				}
			}
			if( estado == 3 ){

				if( (contError = verifyError(TYPEA, NOABNORMAL)) != 0 ){	// Verifica se deu erro de valor fora da faixa ou anormal
					clearLine(3);
					clearLine(5);
					clearLine(7);
					clearLine(9);
					clearLine(11);
					writeLine(13);
					escrita_texto(28, "  ", sizeof("  "));
					stateMachineError(120, contError & 0xFF, 1);	// Escreve mV fora da faixa para os respectivos eletrodos
					stateMachineError(150, contError >> 8, 2);	// Escreve anormal para os respectivos eletrodos
					stateMachineError(90, contError >> 16, 3);
					escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
				}
			}
			break;

		case 3:		// Estado de verificação de erro

			if( contError == 0 ){	// Se não há erro de verificação e se o teste está ok

				escrita_texto( 400, "Finalizado!", sizeof("Finalizado!") );
				vTaskDelay(4000);
				flagBuz = 1;
				return OK;	// Retorna 0

			}
			else{	// Senão
				if( verifyKeyBoard() == yes ){	// Se o botão yes foi pressionado
					estado = 0;	// Estado 0, movimento dos motores
					contError = 0;	// Zera o contador de erro
					contadorCalib = 1; // Reseta o valor do contador de calibração
					clearLine(3);	// Apaga linha 3
					clearLine(4);	// Apaga linha 4
					clearLine(5);	// Apaga linha 5
					clearLine(15);	// Apaga linha 15
					escrita_texto( 394, "Aspirando Calibrador A", sizeof("Aspirando Calibrador A"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else if( verifyKeyBoard() == no )	// Se o botão No foi pressionado
					return ERRO; 	// Retorna o valor do erro de instabilidade
			}

			break;

		}

	}

}

unsigned char calibB( void ){

	unsigned char sample = 0, segundos = 30, estado = 0, erroDiferencaTensoes = 0, texto = 0;
	unsigned int  temporizador = 1000, contError = 0, contReadAD = 0;
	unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	long medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned int medidasCalibSalva[6] = {0,0,0,0,0,0};
	unsigned char contAddrMemoria = 81, contadorCalib = 1, hora, minuto;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;

	writeLine(13);	// Escreve o desenho da linha de separação na tela

	escrita_texto( 9, "Calibrador B", sizeof("Calibrador B"));	// Escreve Calibrador A na posição 9
	escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394

	for( unsigned int i = ADDR_FLASH + 0xF00; i >= ADDR_FLASH + 0x780; i = i - DADOS_SALVOS ){	// Faz a verificação de memória apagada

		if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
			// Armazena no vetor os valores de calibração já feitos
			medidaCalAnterior_K = *(volatile unsigned short *)(i);
			medidaCalAnterior_Na = *(volatile unsigned short *)(i + DADO_MEMORIA);
			medidaCalAnterior_Cl = *(volatile unsigned short *)(i + DADO_MEMORIA * 2);
			medidaCalAnterior_Ca = *(volatile unsigned short *)(i + DADO_MEMORIA * 3);
			medidaCalAnterior_pH = *(volatile unsigned short *)(i + DADO_MEMORIA * 4);
			break;
		}
		contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

	}

	writeLine(13);
	escrita_texto( 0x09, "Calibrador B", sizeof("Calibrador B"));
	escrita_texto( 0x18A, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));

	while( 1 ){		// Enquanto

		switch( estado ){

		case 0:	// Estado 0, movimento dos motores
			// Move motor MUX para posição 3
			move_mux(POSITION3, SPEEDMUX1);

			// Movimenta anti horário em 910ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 910);
			vTaskDelay(TIMERCOM * 8); // Delay de 2 segundos

			// Move motor MUX para a posição 4
			move_mux(POSITION4, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 2,82 s
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 2820);
			vTaskDelay(TIMERCOM / 2); // Delay 125 ms

			// Move motor MUX para a posição 3
			move_mux(POSITION3, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 870ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 870);
			vTaskDelay(TIMERCOM + 50);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1650);
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 3800);
			vTaskDelay(2250);

			// Move motor MUX para a posição 3
			move_mux(POSITION4, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			// Movimenta anti horário em 52ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, 15000);
			vTaskDelay(TIMERCOM);

			if( sample == 0 && contError < 2 )	// Se não detectou líquido e a contagem de error menor que 2
				contError++; // Incrementa contagem de erro

			else if( contError == 2 ){	// Senão se contagem de erro igual a 2

				// Escreve "Falta Calibrador A. Aspirar novamente?" na posição 210
				escrita_texto(210, "Falta Calibrador B. Aspirar novamente?", sizeof("Falta Calibrador B. Aspirar novamente?"));
				escrita_texto(450, "YES=Asp NO=Sair 1=Help", sizeof("YES=Asp NO=Sair 1=Help"));	// Escreve "YES=Asp NO=Sair 1=Help" na posição 450
				estado = 1;	// Estado recebe 1, não detectou líquido
				contError = 0;	// Contagem de erro recebe 0

			}
			else{	// Senão, para a detecção de líquido

				estado = 2;	// Estado recebe 2, mede a tensão dos eletrodos
				contError = 0;	// Contagem de erro recebe 0
				writeLine(13);
				escrita_texto( 401, "Testando", sizeof("Testando") );
				vTaskDelay(10000);	// Delay de 10 segundos
				segundos = 30;
				escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

			}
			break;

		case 1:

			if( verifyKeyBoard() == yes ){	// Se teclado igual a Yes
				estado = 0;	// Estado recebe 0, inicialização e movimento dos motores
				clear_display_text();
				writeLine(13);	// Escreve o desenho da linha de separação na tela

				escrita_texto( 9, "Calibrador B", sizeof("Calibrador B"));	// Escreve Calibrador A na posição 9
				escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394

			}
			else if( verifyKeyBoard() == no )	// Senão se teclado igual a No
				return ERRO;	// Retorna 2

			else if( verifyKeyBoard() == um ){	// Senão se teclado igual a 1

				clearLine(10);	// Limpa a linha 10
				clearLine(11);	// Limpa a linha 11
				clearLine(12);	// Limpa a linha 12
				if( texto == 0 ) // Se se texto igual a 0
					escrita_texto(300, "Verificar a disponibilidade", sizeof("Verificar a disponibilidade"));// Escreve "Verificar a disponibilidade" na posição 330

				else if( texto == 1 )	// Senão se texto igual a 1
					// Escreve "Se a bomba estiver c/ aderencia um som diferente será ouvido"
					escrita_texto(300, "Se a bomba estiver c/ aderencia um som diferente vai ser ouvido", sizeof("Se a bomba estiver c/ aderencia um som diferente vai ser ouvido"));

				else if( texto == 2 )	// Senão se texto igual a 2
					// Escreve "O mau estado dos conectores e anéis de vedação"
					escrita_texto(300, "O mau estado dos conectores e aneis de vedacao", sizeof("O mau estado dos conectores e aneis de vedacao"));

				else if( texto == 3 )// Senão se texto igual a 3
					escrita_texto(300, "A tubulacao c/ entupimento", sizeof("A tubulacao c/ entupimento"));	// Escreve "A tubulação c/ entupimento"

				else	// Senão se texto igual a 4
					// Escreve "Favor ir para MULTIPLEXER CHECK(checar Multiplexador)"
					escrita_texto(300, "Favor ir em MULTIPLEXER CHECK (checar Multiplexador)", sizeof("Favor ir em MULTIPLEXER CHECK(checar Multiplexador)"));

				texto++;	// Texto incrementa
				if( texto == 5 )	// Se texto igual a 5
					texto = 0;	// Texto recebe 0
			}

			break;

		case 2:

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador
					segundos--;
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

					escrita_texto(92, "K  =   8.00 mmol/L  ", sizeof( "K  =   8.00 mmol/L  "));
					escrita_texto(112, numtolcd(voltageCalB_K, CAL), 7);
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na  = 110.00 mmol/L  ", sizeof("Na  = 110.00 mmol/L  "));
					escrita_texto(172, numtolcd(voltageCalB_Na, CAL), 7);
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl  =  70.00 mmol/L  ", sizeof("Cl  =  70.00 mmol/L  "));
					escrita_texto(232, numtolcd(voltageCalB_Cl, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca  =   2.50 mmol/L  ", sizeof("Ca  =   2.50 mmol/L  "));
					escrita_texto(292, numtolcd(voltageCalB_Ca, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH  =   7.00         ", sizeof("pH  =   7.00        "));
					escrita_texto(352, numtolcd(voltageCalB_pH, CAL), 7);
					escrita_texto(358, "mV", sizeof( "mV"));

					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 3;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 1750 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{	// Senão
					voltageCalB_K =	k * 8.0325 / contReadAD;	// Calcula a tensão para k. Medida atual
					voltageCalB_pH = ph * 8.0325 / contReadAD;	// Calcula a tensão para ph. Medida atual
					voltageCalB_Ca = ca * 8.0325 / contReadAD;	// Calcula a tensão para ca. Medida atual
					voltageCalB_Cl = cl * 8.0325 / contReadAD;	// Calcula a tensão para cl. Medida atual
					voltageCalB_Na = na * 8.0325 / contReadAD;	// Calcula a tensão para na. Medida atual
					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;

					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - voltageCalB_K) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - voltageCalB_Na) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - voltageCalB_Cl) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - voltageCalB_Ca) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - voltageCalB_pH) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);
						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}

					if( erroDiferencaTensoes == 0 && segundos < 27 ){	// Se diferença for menor que 500 e segundo menor que 27

						I2C_READ_PCF8653( &hora, Hours ) ;	// Medida de hora do RTC
						I2C_READ_PCF8653( &minuto, Minutes );	// Medida de minuto do RTC
						medidasCalibSalva[0] = voltageCalB_K;	// Salva calibrador K
						medidasCalibSalva[1] = voltageCalB_Na;	// Salva calibrador Na
						medidasCalibSalva[2] = voltageCalB_Cl;	// Salva calibrador Cl
						medidasCalibSalva[3] = voltageCalB_Ca;	// Salva calibrador Ca
						medidasCalibSalva[4] = voltageCalB_pH;	// Salva calibrador pH
						medidasCalibSalva[5] = 0x01 << 24 | bcdtodec(hora & 0x3F) << 16 | bcdtodec(minuto & 0x7F) << 8 | contadorCalib;	// Salva horário, contador de calibração e 0 para calibrador A
						FLASH_Program(&s_flashDriver, ADDR_FLASH + 0x780 + contAddrMemoria * DADOS_SALVOS, medidasCalibSalva, DADOS_SALVOS);	// Salva dados de calibração

						contAddrMemoria++;	// Incrementa contador de memória

						if( abs(medidaCalAnterior_K - voltageCalB_K) > 500 ||
								abs(medidaCalAnterior_Na - voltageCalB_Na) > 500 ||
								abs(medidaCalAnterior_Cl - voltageCalB_Cl) > 500 ||
								abs(medidaCalAnterior_Ca - voltageCalB_Ca) > 500 ||
								abs(medidaCalAnterior_pH - voltageCalB_pH) > 500 ){
							contadorCalib++;
							if( contadorCalib > 3 )
								estado = 3;
							else{
								clearLine(3);
								clearLine(5);
								clearLine(7);
								clearLine(9);
								clearLine(11);
								escrita_texto(28, "  ", sizeof("  "));
								escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394
								estado = 0;
							}
						}
						else{
							estado = 3;
						}
						if( estado != 3 ){
							medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS);	// Lê o valor de calibração anterior K
							medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
							medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
							medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
							medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH
						}
					}
					else if( erroDiferencaTensoes != 0 && segundos == 0 ){	// Senão

						estado = 0;			// Estado recebe 0
						contError++;				// contErro incrementa
						if( contError == 2 ){	// Se contErro igual a 2
							estado = 3;			// Estado recebe 3 (Verificação de erros)
							escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));
						}

					}
					contReadAD = 0;	// Zera contador de leitura AD

					// Medida anterior recebe Medida atual
					medidaAnterior_K = voltageCalB_K;
					medidaAnterior_Na = voltageCalB_Na;
					medidaAnterior_Ca = voltageCalB_Ca;
					medidaAnterior_Cl = voltageCalB_Cl;
					medidaAnterior_pH = voltageCalB_pH;


				}
			}
			if( estado == 3 ){

				if( (contError = verifyError(TYPEB, ABNORMAL)) != 0 ){	// Verifica se deu erro de valor fora da faixa ou anormal
					clearLine(3);
					clearLine(5);
					clearLine(7);
					clearLine(9);
					clearLine(11);
					writeLine(13);
					escrita_texto(28, "  ", sizeof("  "));
					stateMachineError(120, contError & 0xFF, 1);	// Escreve mV fora da faixa para os respectivos eletrodos
					stateMachineError(150, contError >> 8, 2);	// Escreve anormal para os respectivos eletrodos
					stateMachineError(90, contError >> 16, 3);	// Escreve variandp e qual dos eletrodos que não está instável
					escrita_texto(450, "YES=CALIBRAR NO=SAIR", sizeof("YES=CALIBRAR NO=SAIR"));

				}
			}
			break;

		case 3:		// Estado de verificação de erro

			if( contError == 0 ){	// Se não há erro de verificação e se o teste está ok

				escrita_texto( 400, "Finalizado!", sizeof("Finalizado!") );
				vTaskDelay(4000);
				flagBuz = 1;
				return OK;	// Retorna 0

			}
			else{	// Senão
				if( verifyKeyBoard() == yes ){	// Se o botão yes foi pressionado
					estado = 0;	// Estado 0, movimento dos motores
					contError = 0;	// Zera o contador de erro
					contadorCalib = 1; // Reseta o valor do contador de calibração
					clearLine(3);	// Apaga linha 3
					clearLine(4);	// Apaga linha 4
					clearLine(5);	// Apaga linha 5
					clearLine(15);	// Apaga linha 15
					escrita_texto( 394, "Aspirando Calibrador B", sizeof("Aspirando Calibrador B"));	// Escreve "Aspirando Calibrador A" na posição 394
				}
				else if( verifyKeyBoard() == no )	// Se o botão No foi pressionado
					return ERRO; 	// Retorna o valor do erro de instabilidade
			}

			break;

		}

	}
}

unsigned char testeSoro( void ){

	unsigned char sample, contReadAd = 0, estado = 0, segundos = 0, respMotor = 0,  erroDiferencaTensoes = 0;
	unsigned int contReadAD = 0, timeout = 0, temporizador, contError;
	unsigned int medidaAnterior_K = 0, medidaAnterior_Cl = 0, medidaAnterior_Na = 0, medidaAnterior_Ca = 0, medidaAnterior_pH = 0;
	static unsigned long k = 0, na = 0, cl = 0, ph = 0, ca = 0;
	adc16_channel_config_t adc16ChannelConfigStruct;
	adc16ChannelConfigStruct.enableInterruptOnConversionCompleted = false;
	adc16ChannelConfigStruct.enableDifferentialConversion = false;



	while( 1 ){

		switch(estado){
		case 0:	//Início movimento dos motores

			// Movimenta anti horário em 910ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP1, 950);
			vTaskDelay(TIMERCOM + 50); // Delay de 2 segundos

			// Move motor MUX para posição 3
			move_mux(POSITION3, SPEEDMUX1);

			// Movimenta anti horário em 2,82 s
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1000);

			// Movimenta anti horário em 870ms
			sample = move_tripa(WAYAHOUR, SPEEDTRP3, 1000);
			vTaskDelay(TIMERCOM + 50);

			// Move motor MUX para a posição 1
			move_mux(POSITION1, SPEEDMUX1);
			vTaskDelay(TIMERCOM);

			writeLine(13);
			escrita_texto( 271, "Levante a Sonda para Aspirar", sizeof("Levante a Sonda para Aspirar"));
			escrita_texto( 450, "YES=Asp", sizeof("YES=Asp"));
			escrita_texto( 459, "NO=Sair", sizeof("NO=Sair"));
			escrita_texto( 473, "<=Serie", sizeof("<=Serie"));

			estado = 1;
			break;

		case 1:	// Estado 1. Verificação da agulha

			if( agulhaFechada ){	// Se sonda fechada
				if( flag_timer ){	// Se flag timer igual a 1
					flag_timer = 0;	// Flag timer recebe 0
					timeout++;	// Incrementa timeout de 1
					if( timeout >= 60000 || verifyKeyBoard() == no  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

						move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
						clear_display_text();	// Limpa a tela
						calibA(1);
						return OK;

					}
				}
			}
			else if( agulhaAberta ){		// Se Sonda está aberta
				estado = 2;		// Estado recebe 1
				timeout = 0;	// Timeout recebe 0

			}


			break;

		case 2:	// Estado 2. Leitura da sonda e verificação de timeout
			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					calibA(1);
					return OK;

				}
			}
			else if( verifyKeyBoard() == yes ){ 	//
				escrita_texto(401, "Aspirando", sizeof("Aspirando"));		// Escreve “Aspirando“ na linha 390
				move_tripa(WAYAHOUR,SPEEDTRP1,1800);	// Aciona tripa por 2,4 segundos na velocidade 1
				clearLine(7);	// Apaga a linha 7
				clearLine(9);
				escrita_texto(215, "Favor abaixar a Sonda", sizeof("Favor abaixar a Sonda"));	// Escreve “Favor abaixar a Sonda” na posição 210
				while( agulhaAberta );	// Enquanto a sonda está aberta
				clearLine(7);
				respMotor = move_tripa(WAYAHOUR,SPEEDTRP4,15000);	// Aciona tripa por 15 segundos
				if( respMotor == 1 && agulhaFechada ){	// Se detectou líquido
					estado = 3;
					temporizador = 1000;	// Temporizador recebe 1000 para contagem de 1 segundo
					segundos = 30;	// Segundo recebe 59
					writeLine(13);
					escrita_texto( 401, "Testando", sizeof("Testando") );
					vTaskDelay(10000);	// Delay de 10 segundos
					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve segundo
				}
				else{

					estado = 5;	// Estado de erro de detecção de líqudo
					if( agulhaAberta ){	// Se a agulha está aberta
						escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
						while( agulhaAberta );	// Aguarda até a agulha ser abaixada
					}

				}
			}
			else if( verifyKeyBoard() == no ){	// Se teclado igual a No
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				clear_display_text();	// Limpa a tela
				return OK;
			}

			break;

		case 3:	// Se detectou líquido começa a contagem de tempo

			// Inicia contador de 30 segundos
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador

					escrita_texto(28, numtolcd(segundos,NUM), 3);	// Escreve os segundos

					escrita_texto(91, "K    ", sizeof("K   "));
					escrita_texto(97, numtolcd(Ck, CAL), 7);
					escrita_texto(104, "mmol/L", sizeof("mmol/L"));
					escrita_texto(112, numtolcd(k * 8.0325 / contReadAD, CAL), 7);
					escrita_texto(118, "mV", sizeof( "mV"));

					escrita_texto(151, "Na    ", sizeof("K   "));
					escrita_texto(157, numtolcd(Cna, CAL), 7);
					escrita_texto(164, "mmol/L", sizeof("mmol/L"));
					escrita_texto(172, numtolcd(na * 8.0325 / contReadAD, CAL), 7);
					escrita_texto(178, "mV", sizeof( "mV"));

					escrita_texto(211, "Cl    ", sizeof("Cl   "));
					escrita_texto(217, numtolcd(Ccl, CAL), 7);
					escrita_texto(224, "mmol/L", sizeof("mmol/L"));
					escrita_texto(232, numtolcd(cl * 8.0325 / contReadAD, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca    ", sizeof("Ca    "));
					escrita_texto(277, numtolcd(Cca, CAL), 7);
					escrita_texto(284, "mmol/L", sizeof("mmol/L"));
					escrita_texto(292, numtolcd(ca * 8.0325 / contReadAD, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					escrita_texto(331, "pH    ", sizeof("pH    "));
					escrita_texto(337, numtolcd(CpH, CAL), 7);
					escrita_texto(344, "      ", sizeof("      "));
					escrita_texto(352, numtolcd(ph * 8.0325 / contReadAD, CAL), 7);
					escrita_texto(358, "mV", sizeof( "mV"));

					segundos--; // Decrementa segundos
					if( segundos == 0 ){	// Se segundos for igual a 0
						estado = 4;
					}
				}
			}

			if( segundos > 0 ){	// Se segundos maior que 0
				if( contReadAD < 250 ){	// Se contAD menor que 50
					adc16ChannelConfigStruct.channelNumber                        = 8;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ph += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ph e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 9;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					ca += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura ca e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 12;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					cl += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura cl e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 13;
					ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC0, 0)))
					{
					}
					na += ADC16_GetChannelConversionValue(ADC0, 0);	// Faz leitura na e incrementa

					adc16ChannelConfigStruct.channelNumber                        = 14;
					ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
					while (0U == (kADC16_ChannelConversionDoneFlag &
							ADC16_GetChannelStatusFlags(ADC1, 1)))
					{
					}
					k += ADC16_GetChannelConversionValue(ADC1, 1);	// Faz leitura k e incrementa

					contReadAD++;	// Incrementa contAD

				}
				else{
					Ck = Ck_standard * pow( 10, (k * 8.0325 / contReadAD) / ( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) );
					CpH = CpH_standard * pow( 10, (ph * 8.0325 / contReadAD) / ( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) );
					Cca = Cca_standard * pow( 10, (ca * 8.0325 / contReadAD) / ( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) * 100;
					Ccl = Ccl_standard * pow( 10, (cl * 8.0325 / contReadAD) / ( ( voltageCalA_Cl - voltageCalB_Cl ) * 5.105) ) * 100;
					Cna = Cna_standard * pow( 10, (na * 8.0325 / contReadAD) / ( ( voltageCalB_Na - voltageCalA_Na ) * 9.633) );

					// Faz a verificação da diferença e armazena o erro em uma flag
					if( medidaAnterior_K != 0 && medidaAnterior_Ca != 0 && medidaAnterior_Na != 0 && medidaAnterior_Cl != 0 && medidaAnterior_pH != 0 ){

						if( abs(medidaAnterior_K - k * 8.0325 / contReadAD) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorK);
						else
							erroDiferencaTensoes |= 1 << ErrorK;

						if( abs(medidaAnterior_Na - na * 8.0325 / contReadAD) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorNa);
						else
							erroDiferencaTensoes |= 1 << ErrorNa;

						if( abs(medidaAnterior_Cl - cl * 8.0325 / contReadAD) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCl);
						else
							erroDiferencaTensoes |= 1 << ErrorCl;

						if( abs(medidaAnterior_Ca - ca * 8.0325 / contReadAD) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorCa);
						else
							erroDiferencaTensoes |= 1 << ErrorCa;

						if( abs(medidaAnterior_pH - ph * 8.0325 / contReadAD) < 500 )
							erroDiferencaTensoes &= ~(1 << ErrorpH);
						else
							erroDiferencaTensoes |= 1 << ErrorpH;
					}

					k = 0;
					ph = 0;
					ca = 0;
					cl = 0;
					na = 0;
					contReadAD = 0;
					if( erroDiferencaTensoes == 0 && segundos < 27 )
						estado = 4;
					else if(erroDiferencaTensoes == 0 && segundos < 27){

						clearLine(3);
						clearLine(5);
						clearLine(7);
						clearLine(9);
						clearLine(11);
						escrita_texto(28, "  ", sizeof("  "));
						escrita_texto(210, "Eletrodos instaveis, aspirar novamente?", sizeof("Eletrodos instaveis, aspirar novamente?"));	// Escreve "Aspirando Calibrador A" na posição 394
						estado = 7;

					}

				}

				break;

		case 4:	// Estado 4. Temporizador terminou ou teclado No foi pressionado

			respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
			if( respMotor == OK || respMotor == ERRO ){	// Se identificou líquido na lavagem
				clear_display_text();
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				estado = 0;
			}

			break;

		case 5:	// Estado 5. Falta de detecção de líquido

			respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
			if( respMotor == OK || respMotor == ERRO ){	// Se não identificou líquido na lavagem
				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				writeLine(13);	// Desenha na linha 13
				clearLine(8);
				escrita_texto(210, "Sem amostra. Aspirar novamente?", sizeof("Sem amostra. Aspirar novamente?"));	// Escreve “Sem amostra. Aspirar novamente?”
				estado = 7;	// Estado de verificação de botão para retornar ao início
			}


			break;

		case 7:	// Estado 7. Verificação de botão para retornar ao estado inicial

			verifyKeyBoard();
			if( verifyKeyBoard() == yes ){
				clearLine(7);
				clearLine(8);
				escrita_texto(210, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210
				estado = 1;	// Verificação de sonda aberta
			}
			else if( verifyKeyBoard() == no ){

				clear_display_text();	// Limpa a tela
				return ERRO;

			}
			break;



			/*readQueueKeyboard = verifyKeyBoard();

		if( readQueueKeyboard == yes ){

			// Movimenta anti horário em 870ms
			clearLine(9);
			sample = move_tripa(WAYAHOUR, SPEEDTRP2, 1250);
			while( agulhaAberta );
			sample = move_tripa(WAYAHOUR, SPEEDTRP4, 15000);

			if( sample == 0 )
				return 1;
			else{
				while( contReadAd < 20 ){
					while( contAD < 1000 ){

						adc16ChannelConfigStruct.channelNumber                        = 8;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						ph += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 9;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						ca += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 12;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						cl += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 13;
						ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC0, 0)))
						{
						}
						na += ADC16_GetChannelConversionValue(ADC0, 0);

						adc16ChannelConfigStruct.channelNumber                        = 14;
						ADC16_SetChannelConfig(ADC1, 1, &adc16ChannelConfigStruct);
						while (0U == (kADC16_ChannelConversionDoneFlag &
								ADC16_GetChannelStatusFlags(ADC1, 1)))
						{
						}
						k += ADC16_GetChannelConversionValue(ADC1, 1);

						contAD++;
					}
					Ck = Ck_standard * pow( 10, (k * 8.0325 / contAD) / ( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) );
					CpH = CpH_standard * pow( 10, (ph * 8.0325 / contAD) / ( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) );
					Cca = Cca_standard * pow( 10, (ca * 8.0325 / contAD) / ( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) * 100;
					Ccl = Ccl_standard * pow( 10, (cl * 8.0325 / contAD) / ( ( voltageCalA_Cl - voltageCalB_Cl ) * 5.105) ) * 100;
					Cna = Cna_standard * pow( 10, (na * 8.0325 / contAD) / ( ( voltageCalB_Na - voltageCalA_Na ) * 9.633) );


					escrita_texto(211, "Cl    ", sizeof("Cl   "));
					escrita_texto(217, numtolcd(Ccl, CAL), 7);
					escrita_texto(224, "mmol/L", sizeof("mmol/L"));
					escrita_texto(232, numtolcd(cl * 8.0325 / contAD, CAL), 7);
					escrita_texto(238, "mV", sizeof( "mV"));

					escrita_texto(271, "Ca    ", sizeof("Ca    "));
					escrita_texto(277, numtolcd(Cca, CAL), 7);
					escrita_texto(284, "mmol/L", sizeof("mmol/L"));
					escrita_texto(292, numtolcd(ca * 8.0325 / contAD, CAL), 7);
					escrita_texto(298, "mV", sizeof( "mV"));

					k = 0;
					na = 0;
					ca = 0;
					ph = 0;
					cl = 0;
					contReadAd++;
					contAD = 0;

				}
				contReadAd = 0;
				readQueueKeyboard = 0;
				vTaskDelay( 5000 );
				clearLine(7);
				clearLine(9);
			}
		}*/
			}
		}
	}
	return 0;
}

char *numtolcd( unsigned int num, unsigned char typeCalOrNum ){

	const int dm = 10000, m = 1000;
	const char c = 100, d = 10;

	if( typeCalOrNum == CAL ){
		if( num > dm ){

			data[0] = num / dm + 0x30;
			data[1] = ( num % dm ) / m + 0x30;
			data[2] = ( ( num % dm ) % m ) / c + 0x30;
			data[3] = 0x0E + 0x20;	// Vírgula no código LCD
			data[4] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
		else if( num > m ){

			data[0] = 0x20; // Espaço no código LCD
			data[1] = num / m + 0x30;
			data[2] = ( ( num % m ) ) / c + 0x30;
			data[3] = 0x0E + 0x20; // Vírgula no código LCD
			data[4] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
	}
	else if( typeCalOrNum == NUM ){

		if( num < c ){
			if( num < d )
				data[0] = 0x30; // Espaço no código LCD

			else
				data[0] = num / 10 + 0x30;; // Espaço no código LCD

			data[1] = num % 10 + 0x30;
			data[2] = 0;
			data[3] = 0;
			data[4] = 0;
			data[5] = 0;
		}
		else{

			data[0] = num / dm + 0x30;
			data[1] = ( num % dm ) / m + 0x30;
			data[2] = ( ( num % dm ) % m ) / c + 0x30;
			data[3] = ( ( ( num % dm ) % m ) % c ) / d + 0x30;
			data[4] = 0x0E + 0x20;	// Vírgula no código LCD
			data[5] = ( ( ( num % dm ) % m ) % c ) % d + 0x30;

		}
	}
	return (data);

}

unsigned char writeLine( unsigned int line ){

	if( line > 15 )
		return 0;
	line = line * 30;
	send_data(line & 0xFF);
	send_data(line >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( char i = 0; i < 30; i++ ){
		send_data(0x82);
	}

	send_command(Auto_reset);
	status(2);

	return 1;

}


unsigned char clearLine( unsigned int line ){

	if( line > 15 )
		return 0;
	line = line * 30;
	send_data(line & 0xFF);
	send_data(line >> 8);
	send_command(Set_address_pointer);
	status(1);

	send_command(Set_data_auto_write);
	status(2);

	// Apaga os textos na tela de texto
	for( char i = 0; i < 30; i++ ){
		send_data(0x00);
	}

	send_command(Auto_reset);
	status(2);

	return 1;

}

void writeMenuName( unsigned char menu ){

	static unsigned char menu_anterior;
	clearLine(12);
	if( menu == 0 )
		escrita_texto(371, "1 PONTO", sizeof("1 PONTO"));
	if( menu == 1 )
		escrita_texto(371, "2 PONTOS", sizeof("2 PONTOS"));
	if( menu == 2 ){
		escrita_texto(370, "MANUTEN", sizeof("MANUTEN"));
		send_data(0x60);
		send_command(0xC0);
		status(1);
		send_data(0x81);
		send_command(0xC0);
		status(1);
		send_data(0x2F);
		send_command(0xC0);
		status(1);
	}
	if( menu == 3 )
		escrita_texto(368, "TESTE DE SORO", sizeof("TESTE DE SORO"));
	if( menu == 4 )
		escrita_texto(364, "TESTE DE SANGUE TOTAL", sizeof("TESTE DE SANGUE TOTAL"));
	if( menu == 5 )
		escrita_texto(368, "TESTE DE URINA", sizeof("TESTE DE URINA"));
	if( menu == 6 )
		escrita_texto(368, "TESTE DE C.Q.", sizeof("TESTE DE C.Q."));
	if( menu == 7 ){
		escrita_texto(368, "CONFIGURA", sizeof("CONFIGURA"));
		send_data(0x60);
		send_command(0xC0);
		status(1);
		send_data(0x81);
		send_command(0xC0);
		status(1);
		send_data(0x2F);
		send_command(0xC0);
		status(1);
	}
	if( menu == 8 ){
		escrita_texto(372, "SERVI", sizeof("SERVI"));
		send_data(0x60);
		send_command(0xC0);
		status(1);
		send_data(0x2F);
		send_command(0xC0);
		status(1);
	}
	desenha_fundo_menu( menu_anterior % 4, 0 );
	if( ( menu_anterior == 8 || menu_anterior == 4 ) && ( menu >= 0 && menu < 4 ) )
		desenho_menu1();
	else if( ( menu_anterior == 3 || menu_anterior == 8 )  && ( menu >= 4 && menu < 8 ))
		desenho_menu2();
	else if( ( menu_anterior == 7 || menu_anterior == 0 ) && ( menu == 8 )  )
		desenho_menu3();
	desenha_fundo_menu( menu % 4, 1 );
	send_command(Mode_set_exor);
	status(1);
	menu_anterior = menu;

}

void calibValues( void ){

	Ck_standard = 4 / ( pow( 10, ( voltageCalA_K  / (float)( ( voltageCalB_K - voltageCalA_K ) * 3.32 ) ) ) );
	Cna_standard = 140 / ( pow( 10, voltageCalA_Na / (float)( ( voltageCalA_Na - voltageCalB_Na ) * 9.633) ) );
	Ccl_standard = 110 / ( pow( 10, voltageCalA_Cl / (float)( ( voltageCalA_Cl - voltageCalB_Cl ) * 5.105 ) ) );
	Cca_standard = 1.25 / ( pow( 10, voltageCalA_Ca / (float)( ( voltageCalB_Ca - voltageCalA_Ca ) * 3.31 ) ) );
	CpH_standard = 7.4 / ( pow( 10, voltageCalA_pH / (float)( ( voltageCalB_pH - voltageCalA_pH ) * 47.19 ) ) );

}

unsigned int verifyError( unsigned char typeAorB, unsigned char abnormal ){

	unsigned char contError = 0, contErrorAbnormal = 0;
	unsigned int medidaCalAnterior_K = 0, medidaCalAnterior_Cl = 0, medidaCalAnterior_Na = 0, medidaCalAnterior_Ca = 0, medidaCalAnterior_pH = 0;
	unsigned char contAddrMemoria = 80, erroDiferencaTensoes = 0;

	if( typeAorB == 1 ){
		if( voltageCalA_K < 4500 || voltageCalA_K > 14000 )
			contError |= 1 << ErrorK;
		else
			contError &= ~(1 << ErrorK);

		if( voltageCalA_Na < 4500 || voltageCalA_Na > 12000 )
			contError |= 1 << ErrorNa;
		else
			contError &= ~(1 << ErrorNa);

		if( voltageCalA_Cl < 5000 || voltageCalA_Cl > 12000 )
			contError |= 1 << ErrorCl;
		else
			contError &= ~(1 << ErrorCl);

		if( voltageCalA_Ca < 3500 || voltageCalA_Ca > 10000 )
			contError |= 1 << ErrorCa;
		else
			contError &= ~(1 << ErrorCa);

		if( voltageCalA_pH < 4500 || voltageCalA_pH > 14000 )
			contError |= 1 << ErrorpH;
		else
			contError &= ~(1 << ErrorpH);

		for( unsigned int i = ADDR_FLASH + 0x768; i >= ADDR_FLASH; i = i - DADOS_SALVOS ){	// Faz a verificação de memória apagada

			if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
				// Armazena no vetor os valores de calibração já feitos
				break;
			}
			contAddrMemoria--;

		}
		medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS);	// Lê o valor de calibração anterior K
		medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
		medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
		medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
		medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_FLASH + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH

		if( abs(medidaCalAnterior_K - voltageCalA_K) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorK);
		else
			erroDiferencaTensoes |= 1 << ErrorK;

		if( abs(medidaCalAnterior_Na - voltageCalA_Na) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorNa);
		else
			erroDiferencaTensoes |= 1 << ErrorNa;

		if( abs(medidaCalAnterior_Cl - voltageCalA_Cl) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCl);
		else
			erroDiferencaTensoes |= 1 << ErrorCl;

		if( abs(medidaCalAnterior_Ca - voltageCalA_Ca) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCa);
		else
			erroDiferencaTensoes |= 1 << ErrorCa;

		if( abs(medidaCalAnterior_pH - voltageCalA_pH) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorpH);
		else
			erroDiferencaTensoes |= 1 << ErrorpH;

	}
	else{
		if( voltageCalB_K < 4500 || voltageCalB_K > 14000 )
			contError |= 1 << ErrorK;
		else
			contError &= ~(1 << ErrorK);

		if( voltageCalB_Na < 4500 || voltageCalB_Na > 12000 )
			contError |= 1 << ErrorNa;
		else
			contError &= ~(1 << ErrorNa);

		if( voltageCalB_Cl < 5000 || voltageCalB_Cl > 12000 )
			contError |= 1 << ErrorCl;
		else
			contError &= ~(1 << ErrorCl);

		if( voltageCalB_Ca < 3500 || voltageCalB_Ca > 10000 )
			contError |= 1 << ErrorCa;
		else
			contError &= ~(1 << ErrorCa);

		if( voltageCalB_pH < 4500 || voltageCalB_pH > 14000 )
			contError |= 1 << ErrorpH;
		else
			contError &= ~(1 << ErrorpH);


		for( unsigned int i = ADDR_FLASH + 0xEE8; i >= ADDR_FLASH + 0x780; i = i - DADOS_SALVOS ){	// Faz a verificação de memória apagada

			if( *(volatile unsigned int *)(i) != 0xFFFFFFFF ){	// Se a memória foi escrita
				// Armazena no vetor os valores de calibração já feitos
				break;
			}
			contAddrMemoria--; // Caso não tenha encontrado memória, decrementa contador de endereço

		}
		medidaCalAnterior_K = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS);	// Lê o valor de calibração anterior K
		medidaCalAnterior_Na = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA);	// Lê o valor de calibração anterior Na
		medidaCalAnterior_Cl = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*2);	// Lê o valor de calibração anterior Cl
		medidaCalAnterior_Ca = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*3);	// Lê o valor de calibração anterior Ca
		medidaCalAnterior_pH = *(volatile unsigned short *)(ADDR_FLASH + 0x780 + (contAddrMemoria - 1) * DADOS_SALVOS + DADO_MEMORIA*4);	// Lê o valor de calibração anterior pH

		if( abs(medidaCalAnterior_K - voltageCalB_K) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorK);
		else
			erroDiferencaTensoes |= 1 << ErrorK;

		if( abs(medidaCalAnterior_Na - voltageCalB_Na) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorNa);
		else
			erroDiferencaTensoes |= 1 << ErrorNa;

		if( abs(medidaCalAnterior_Cl - voltageCalB_Cl) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCl);
		else
			erroDiferencaTensoes |= 1 << ErrorCl;

		if( abs(medidaCalAnterior_Ca - voltageCalB_Ca) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorCa);
		else
			erroDiferencaTensoes |= 1 << ErrorCa;

		if( abs(medidaCalAnterior_pH - voltageCalB_pH) < 500 )	// Se a variação entre duas calibrações é menor que 0,5, ok, senão, erro
			erroDiferencaTensoes &= ~(1 << ErrorpH);
		else
			erroDiferencaTensoes |= 1 << ErrorpH;

	}
	if( abnormal ){	// Erro anormal, variação entre calibração A e B

		if( (voltageCalB_K - voltageCalA_K) < 1200 ||  (voltageCalB_K - voltageCalA_K) > 2100 )
			contErrorAbnormal |= 1 << ErrorK;
		else
			contErrorAbnormal &= ~(1 << ErrorK) ;

		if( (voltageCalA_Na - voltageCalB_Na) < 420 ||  (voltageCalA_Na - voltageCalB_Na) > 730 )
			contErrorAbnormal |= 1 << ErrorNa;
		else
			contErrorAbnormal &= ~(1 << ErrorNa);

		if( (voltageCalB_Cl - voltageCalA_Cl) < 540 ||  (voltageCalB_Cl - voltageCalA_Cl) > 1080 )
			contErrorAbnormal |= 1 << ErrorCl;
		else
			contErrorAbnormal &= ~(1 << ErrorCl);

		if( (voltageCalB_Ca - voltageCalA_Ca) < 660 ||  (voltageCalB_Ca - voltageCalA_Ca) > 1050 )
			contErrorAbnormal |= 1 << ErrorCa;
		else
			contErrorAbnormal &= ~(1 << ErrorCa);

		if( (voltageCalB_pH - voltageCalA_pH) < 1600 ||  (voltageCalB_pH - voltageCalA_pH) > 2800 )
			contErrorAbnormal |= 1 << ErrorpH;
		else
			contErrorAbnormal &= ~(1 << ErrorpH);

	}

	return erroDiferencaTensoes << 16 | contErrorAbnormal << 8 | contError;
}

void stateMachineError( unsigned int position, unsigned char error, unsigned char typeError ){

	switch( error ){

	case 1:

		escrita_texto(position, "K", sizeof("K"));

		break;

	case 2:

		escrita_texto(position, "Na", sizeof("Na"));

		break;

	case 3:

		escrita_texto(position, "K,Na",sizeof("K,Na"));

		break;

	case 4:

		escrita_texto(position, "Cl",sizeof("Cl"));

		break;

	case 5:

		escrita_texto(position, "K,Cl",sizeof("K,Cl"));

		break;

	case 6:

		escrita_texto(position, "K,Na",sizeof("K,Na"));

		break;

	case 7:

		escrita_texto(position, "K,Na,Cl",sizeof("K,Na,Cl"));

		break;

	case 8:

		escrita_texto(position, "Ca",sizeof("Ca"));

		break;

	case 9:

		escrita_texto(position, "K,Ca",sizeof("K,Ca"));

		break;

	case 10:

		escrita_texto(position, "Na,Ca",sizeof("Na,Ca"));

		break;

	case 11:

		escrita_texto(position, "K,Na,Ca",sizeof("K,Na,Ca"));

		break;

	case 12:

		escrita_texto(position, "Cl,Ca",sizeof("Cl,Ca"));

		break;

	case 13:

		escrita_texto(position, "K,Cl,Ca",sizeof("K,Cl,Ca"));

		break;

	case 14:

		escrita_texto(position, "Na,Cl,Ca",sizeof("Na,Cl,Ca"));

		break;

	case 15:

		escrita_texto(position, "K,Na,Cl,Ca",sizeof("K,Na,Cl,Ca"));

		break;

	case 16:

		escrita_texto(position, "pH",sizeof("pH"));

		break;

	case 17:

		escrita_texto(position, "K,pH",sizeof("K,pH"));

		break;

	case 18:

		escrita_texto(position, "Na,pH",sizeof("Na,pH"));

		break;

	case 19:

		escrita_texto(position, "K,Na,pH",sizeof("K,Na,pH"));

		break;

	case 20:

		escrita_texto(position, "Cl,pH",sizeof("Cl,pH"));

		break;

	case 21:

		escrita_texto(position, "K,Cl,pH",sizeof("K,Cl,pH"));

		break;

	case 22:

		escrita_texto(position, "Na,Cl,pH",sizeof("Na,Cl,pH"));

		break;

	case 23:

		escrita_texto(position, "K,Na,Cl,Ph",sizeof("K,Na,Cl,Ca"));

		break;

	case 24:

		escrita_texto(position, "Ca,pH",sizeof("Ca,pH"));

		break;

	case 25:

		escrita_texto(position, "K,Ca,pH",sizeof("K,Ca,pH"));

		break;

	case 26:

		escrita_texto(position, "Na,Ca,pH",sizeof("Na,Ca,pH"));

		break;

	case 27:

		escrita_texto(position, "K,Na,Ca,pH",sizeof("K,Na,Ca,pH"));

		break;

	case 28:

		escrita_texto(position, "Cl,Ca,pH",sizeof("Cl,Ca,pH"));

		break;

	case 29:

		escrita_texto(position, "K,Cl,Ca,pH",sizeof("K,Cl,Ca,pH"));

		break;

	case 30:

		escrita_texto(position, "Na,Cl,Ca,pH",sizeof("Na,Cl,Ca,pH"));

		break;

	case 31:

		escrita_texto(position, "K,Na,Cl,Ca,pH",sizeof("K,Na,Cl,Ca,pH"));

		break;

	}
	if( error != 0 ){
		if( typeError == 1 )
			escrita_texto(position + 13, "mV fora da faixa",sizeof("mV fora da faixa"));
		else if( typeError == 2 )
			escrita_texto(position + 13, "ANORMAL",sizeof("ANORMAL"));
		else
			escrita_texto(position + 13, "VARIANDO",sizeof("VARIANDO"));
	}

}

unsigned char verifyKeyBoard( void ){

	/*
	 * Função responsável por fazer a leitura de verificação do teclado e
	 * retornar o valor do teclado. Quando não tiver mais espaço vazio na fila
	 * ele lê o valor da fila do teclado e retorna este valor.
	 */

	/* Variável de escrita de espaço da fila e variável de leitura do teclado */
	int emptyKeyboard = uxQueueSpacesAvailable(fila_teclado), readQueueKeyboard = 0;	// Verifica se a fila está com dados

	if( emptyKeyboard == 0 ){	// Se espaço na fila é 0

		xQueueReceive(fila_teclado, &readQueueKeyboard, portTICK_PERIOD_MS);	// Faz a leitura da fila
		vTaskDelay(25);	// Para a task por 10ms
		flagBuz = 1;	// Seta a flag de apito

	}

	return readQueueKeyboard; // Retorna o valor do teclado pressionado
}


void initEquip( void ){

	unsigned char readKeyBoard = 0, flagEnd = 0;
	unsigned int  vPot = 0, vBat = 0;
	adc16_channel_config_t adc16ChannelConfigStruct;

	// Move MUX para a posição 3. Ele já faz esse movimento na inicialização do sistema

	desenho_inicializacao();// Desenho da tela inicial

	send_command(Display_mode_text | Display_mode_graphic); // Comando para desenho de texto e gráfico
	status(1);

	move_tripa(WAYAHOUR, SPEEDTRP1, 900);	// Move tripa na velocidade 1 por 900ms

	move_tripa(WAYAHOUR, SPEEDTRP2, 4000);	// Move tripa na velocidade 2 por 4 segundos

	move_mux(POSITION1, SPEEDMUX1);	// Move MUX para a posição 1

	if( (readKeyBoard = verifyKeyBoard()) != no ){	// Se No não está apertado

		while( !flagEnd ){
			readKeyBoard = 0;	// Zera a variável do teclado
			clear_display_text();	// Limpa a tela

			send_command(Display_mode_text);	// Envia comando para desenho apenas de display
			status(1);

			escrita_texto(10, "AUTO TESTE", sizeof("AUTO TESTE"));	// Desenha a tela de Auto teste

			escrita_texto(60, "1.Bateria de Backup", sizeof("1.Bateria de Backup")); // Escreve "1. Bateria de Backup"

			escrita_texto(120, "2.Nivel do detector de amostra", sizeof("2.Nivel do detector de amostra"));	// Escreve "2. Nível do detector de amostra"

			escrita_texto(180, "3.Tubula", sizeof("3.Tubula"));	// Escreve "3. Tubulação do Calibrador A"
			send_data(0x60);		// Comando para Ç
			send_command(0xC0);
			status(1);
			send_data(0x81);		// Comando para Ã
			send_command(0xC4);
			status(1);
			escrita_texto(190, "o do Calibrador A", sizeof("o do Calibrador A"));	// Escreve "3. Tubulação do Calibrador A"

			escrita_texto(240, "4.Tubula", sizeof("4.Tubula"));	// Escreve "4. Tubulação do Calibrador B"
			send_data(0x60);		// Comando para Ç
			send_command(0xC0);
			status(1);
			send_data(0x81);		// Comando para Ã
			send_command(0xC4);
			status(1);
			escrita_texto(250, "o do Calibrador B", sizeof("o do Calibrador B"));	// Escreve "3. Tubulação do Calibrador A"

			/* Verificação da tensão da bateria */

			adc16ChannelConfigStruct.channelNumber                        = 23;
			ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
			unsigned char contReadAD = 0;
			while( contReadAD < 10 ){
				contReadAD++;
				ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
				while (0U == (kADC16_ChannelConversionDoneFlag &
						ADC16_GetChannelStatusFlags(ADC0, 0)))
				{
				}
				vBat += ADC16_GetChannelConversionValue(ADC0, 0);
			}
			vBat /= contReadAD;
			if( vBat < 3000 )
				escrita_texto(117, "X", sizeof("X"));	// Escreve X indicando erro na bateria
			else
				escrita_texto(117, "OK", sizeof("OK"));// Caso a bateria esteja boa, escreve OK, senão X posição 115. Fazer a verificação da bateria por outro AD

			/* Verificação da tensão do potenciômetro */

			escrita_texto(420, "Ajuste Rxx para 800mV +- 50mV", sizeof("Ajuste Rxx para 800mV +- 50mV"));	// Escreve no final da tela "Alterar o Rxx para 800mV +- 50"

			escrita_texto(450, "NO=Sair", sizeof("NO=Sair"));

			adc16ChannelConfigStruct.channelNumber                        = 4;
			ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
			while( ( readKeyBoard = verifyKeyBoard() ) != no || ( vPot < 968 && vPot > 1018 ) ){ // Verifica o comando do teclado se é diferente de NO

				ADC16_SetChannelConfig(ADC0, 0, &adc16ChannelConfigStruct);
				while (0U == (kADC16_ChannelConversionDoneFlag &
						ADC16_GetChannelStatusFlags(ADC0, 0)))
				{
				}
				vPot = ADC16_GetChannelConversionValue(ADC0, 0);// Mostra o nível de tensão medido no detector de amostra posição 165
				escrita_texto(169, numtolcd(vPot*8.0566, NUM), 7);
				escrita_texto(176, "mV", sizeof("mV"));
			}
			clearLine(5);	// Limpa a 5° linha de texto
			clearLine(14);	// Limpa a 14° linha de texto
			clearLine(15);	// Limpa a 15° linha de texto
			if( vPot > 968 && vPot < 1018 )
				escrita_texto(177, "OK", sizeof("OK")); // Caso esteja em 0.78 e 0.82 V, escreve OK na tela
			else
				escrita_texto(177, "X", sizeof("X")); // Caso esteja em 0.78 e 0.82 V, escreve OK na tela


			// Faz o acionamento dos motores de calibração A
			unsigned char contTestA = 0, respMoveTrip;
			while( contTestA != 3 ){		// Enquanto conTest for diferente de 3 tentativas

				move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
				move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
				move_tripa(WAYAHOUR, SPEEDTRP2, 1500);	// Move motor tripa de mico por 1240 milissegundos
				move_mux(POSITION1, SPEEDMUX1);		// Move motor MUX para posição 1
				vTaskDelay(520);	// Delay de 520ms
				move_mux(POSITION2, SPEEDMUX1);		// Move motor MUX para posição 2
				respMoveTrip = move_tripa(WAYAHOUR, SPEEDTRP4, 11000);	// Move o motor tripa de mico por 11 segundos
				if( respMoveTrip == 0 ){	// Se a resposta for igual a 0, incrementa 1 na variável contTeste
					contTestA++;
					if( contTestA == 3 )
						escrita_texto(237, "X", sizeof("X"));	// Caso a tubulação esteja ruim escreve X posição 225
				}
				else{
					escrita_texto(237, "OK", sizeof("OK"));	// Caso a tubulação esteja boa escreve OK na posição 225
					break;
				}
			}

			// Faz o acionamento dos motores de calibração B
			unsigned char contTestB = 0;
			while( contTestB != 3 ){		// Enquanto contTest for diferente de 3 tentativas

				move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
				move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
				move_tripa(WAYAHOUR, SPEEDTRP2, 3000);	// Move motor tripa de mico por 1240 milissegundos
				move_mux(POSITION1, SPEEDMUX1);		// Move motor MUX para posição 1
				vTaskDelay(520);	// Delay de 520ms
				move_mux(POSITION4, SPEEDMUX1);		// Move motor MUX para posição 4
				respMoveTrip = move_tripa(WAYAHOUR, SPEEDTRP4, 11000);	// Move o motor tripa de mico por 11 segundos
				if( respMoveTrip == 0 ){	// Se a resposta for igual a 0, incrementa 1 na variável contTeste
					contTestB++;
					if( contTestB == 3 )
						escrita_texto(297, "X", sizeof("X")); // Caso a tubulação esteja ruim escreve X posição 345
				}
				else{
					escrita_texto(297, "OK", sizeof("OK")); // Caso a tubulação esteja boa escreve OK na posição 345
					break;
				}
			}
			readKeyBoard = 0;
			// Verifica se teve algum erro no autoteste
			unsigned int timeout = 0;
			if( contTestA == 3 || contTestB == 3 || vBat < 3000 || (( vPot < 968 ) && ( vPot > 1018 )) ){
				escrita_texto(330, "Refazer o autoteste?", sizeof("Refazer o autoteste?"));
				escrita_texto(360, "YES=Sim NO=Sair", sizeof("YES=Sim NO=Sair"));
				while( timeout < 60000 ){	// Timeout de 1 minuto
					if( flag_timer ){
						flag_timer = 0;
						timeout++;
					}
					readKeyBoard = verifyKeyBoard(); // Veriifca o comando pressionado
					if( readKeyBoard == yes ){	// Se o comando pressionado for Yes, repete o autoteste
						contTestA = 0;
						contTestB = 0;
						flagEnd = 0;
						break;
					}
					else if( readKeyBoard == no ){	// Se for não, sai do autoteste
						flagEnd = 1;
						break;
					}
				}
				if( timeout >= 60000) // Caso tenha dado 1 minuto, sai do loop de autoteste
					flagEnd = 1;
			}

		}

	}
	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move motor tripa de mico por 920 milissegundos
	move_mux(POSITION3, SPEEDMUX1);		// Move motor MUX para posição 3
	move_tripa(WAYAHOUR, SPEEDTRP2, 3000);	// Move motor tripa de mico por 3000 milissegundos
	clear_display_text();	// Limpa a tela
}

void limpezaTubulacao( void ){

	clear_display_text();	// Limpa a tela
	// Escreve "limpeza de tubulação" na posição 215
	escrita_texto(215, "Limpeza de tubula", sizeof("Limpeza de tubula"));
	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);
	// Escreve "NO=Sair" na posição 460
	escrita_texto(460, "NO=Sair", sizeof("NO=Sair"));
	move_mux(POSITION5, SPEEDMUX1);		// Move MUX para posição 5
	move_tripa(WAYAHOUR, SPEEDTRP4, 47000);	// Move tripa por 47 segundos na velocidade 4
	move_mux(POSITION3, SPEEDMUX1);	// Move Mux para a posição 3
	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripva por 920ms na velocidade 1
	move_tripa(WAYAHOUR, SPEEDTRP4, 1000);	// Move tripa por 1 segundo na velocidade 4
	move_mux(POSITION1, SPEEDMUX1);	// Move Mux para a posição 1

	unsigned int temporizador = 1000;
	unsigned char readKeyboard = 0, flag10min = 0, minuto = 5, segundo = 59;

	escrita_texto(28, numtolcd(segundo,NUM), 3);
	escrita_texto(27, ":", sizeof(":"));
	escrita_texto(25, numtolcd(minuto-1,NUM),3);
	while( ( readKeyboard = verifyKeyBoard() ) != no ){	// Enquanto o teclado for diferente de NO

		if( flag_timer ){	// Se flag timer ativar
			flag_timer = 0;	// Zera o flag timer
			temporizador--;	// Decrementa o temporizador
			if( temporizador == 0 ){	// Se temporizador chegar a 0
				temporizador = 1000;	// Reinicia o temporizador
				segundo--;
				escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
				if( segundo == 0 ){	// Se segundos for igual a 0
					segundo = 59;	// Reinicia o valor do segundo
					minuto--;
					if( minuto == 0 && flag10min == 0  ){// Se o temporizador chegar a 0 e flag de 10 minutos é igual a 0
						minuto = 10;	// Temporizador recebe 10 minutos
						move_mux(POSITION2, SPEEDMUX1);	// Move Mux para a posição 2
						move_tripa(WAYAHOUR, SPEEDTRP4, 16000);	// Aciona tripa por 16 segundos na velocidade 4
						move_mux(POSITION1, SPEEDMUX1);	// Move Mux para a posição 1
						flag10min = 1;	// Seta o flag de 10 minutos
					}
					else if( minuto == 0 && flag10min == 1 )	// Se temporizador igual a 0 e deu 10 minutos
						break;
					escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
					escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
				}
			}
		}
	}
	move_mux( POSITION3, SPEEDMUX1 );	// Move Mux para posição 3
	move_tripa( WAYAHOUR, SPEEDTRP1, 920 );	// Aciona tripa por 920ms na velocidade 1
	move_tripa( WAYAHOUR, SPEEDTRP4, 1000 );	// Move tripa por 1 segundo na velocidade 4
	vTaskDelay(520);// Delay de 520 ms
	move_tripa( WAYHOUR, SPEEDTRP1, 920 );	// Aciona tripa por 920ms na velocidade 1 no sentido horário
	move_tripa( WAYAHOUR, SPEEDTRP1, 920 );// Aciona tripa por 920ms na velocidade 1 no sentido anti-horário
	move_mux( POSITION3, SPEEDMUX1 ); // Move Mux para posição 3
	calibA(1);	// Função lavando calib(1)
}

void condicionamento( void ){

	// Declaraçãod das variáveis
	unsigned char estado = 0, minuto = 5, segundo = 59, respMotor = 0, readKeyboard = 0;
	unsigned int temporizador = 0, timeout = 0;

	clear_display_text();	// Apaga a tela

	move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripa por 920ms velocidade 1

	move_mux(POSITION3, SPEEDMUX1);		// Move mux para a posição 3

	move_tripa(WAYAHOUR, SPEEDTRP2, 5000);		// Move tripa por 5 segundos velocidade 1

	escrita_texto(8, "CONDICIONAMENTO", sizeof("CONDICIONAMENTO"));

	writeLine(13);

	escrita_texto(211, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210

	escrita_texto( 450, "YES=Asp NO=Sair", sizeof("YES=Asp NO=Sair"));	// Escreve Comandos na tela
	while( 1 ){		switch(estado){

	case 0:	// Estado 0. Início movimento dos motores

		if( agulhaFechada ){	// Se sonda fechada
			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000 || (readKeyboard = verifyKeyBoard()) == no  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Escreve tela de Manutenção
					return;

				}
			}
		}
		else if( agulhaAberta ){		// Se Sonda está aberta
			estado = 1;		// Estado recebe 1
			timeout = 0;	// Timeout recebe 0
		}


		break;

	case 1:	// Estado 1. Leitura da sonda e verificação de timeout
		if( flag_timer ){	// Se flag timer igual a 1
			flag_timer = 0;	// Flag timer recebe 0
			timeout++;	// Incrementa timeout de 1
			if( timeout >= 60000  ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

				move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
				clear_display_text();	// Limpa a tela
				telaManutencao();	// Escreve tela de Manutenção
				return;

			}
		}
		else if( (readKeyboard = verifyKeyBoard()) == yes ){ 	//
			escrita_texto(401, "Aspirando", sizeof("Aspirando"));		// Escreve “Aspirando“ na linha 390
			move_tripa(WAYAHOUR,SPEEDTRP1,2400);	// Aciona tripa por 2,4 segundos na velocidade 1
			clearLine(7);	// Apaga a linha 7
			escrita_texto(215, "Favor abaixar a Sonda", sizeof("Favor abaixar a Sonda"));	// Escreve “Favor abaixar a Sonda” na posição 210
			while( agulhaAberta );	// Enquanto a sonda está aberta
			clearLine(7);
			respMotor = move_tripa(WAYAHOUR,SPEEDTRP4,15000);	// Aciona tripa por 15 segundos
			if( respMotor == 1 && agulhaFechada ){	// Se detectou líquido
				estado = 3;
				temporizador = 1000;	// Temporizador recebe 1000 para contagem de 1 segundo
				minuto = 5;	// Minuto recebe 5
				segundo = 59;	// Segundo recebe 59
				escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve segundo
				escrita_texto(27, ":", sizeof(":"));	// Escreve :
				escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve minutos - 1
			}
			else{

				estado = 5;	// Estado de erro de detecção de líqudo
				if( agulhaAberta ){	// Se a agulha está aberta
					escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
					while( agulhaAberta );	// Aguarda até a agulha ser abaixada
				}

			}
		}
		else if( (readKeyboard = verifyKeyBoard()) == no ){	// Se teclado igual a No
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;
		}

		break;

	case 3:	// Se detectou líquido começa a contagem de tempo

		if( minuto > 0 && (readKeyboard = verifyKeyBoard()) != no ){// Enquanto minuto for maior que 0 e teclado diferente de No
			if( flag_timer ){	// Se flag timer ativar
				flag_timer = 0;	// Zera o flag timer
				temporizador--;	// Decrementa o temporizador
				if( temporizador == 0 ){	// Se temporizador chegar a 0
					temporizador = 1000;	// Reinicia o temporizador
					segundo--;
					escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
					if( segundo == 0 ){	// Se segundos for igual a 0
						segundo = 59;	// Reinicia o valor do segundo
						minuto--;	// Minuto decrementa
						if( minuto == 0 ){	// Se temporizador igual a 0 e deu 10 minutos
							estado = 4;
						}
						escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
					}
				}
			}
		}
		else{
			estado = 4;	// Estado para funcionamento correto
		}

		break;

	case 4:	// Estado 4. Temporizador terminou ou teclado No foi pressionado

		respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
		if( respMotor == 0 || respMotor == 2 ){	// Se identificou líquido na lavagem
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;
		}

		break;

	case 5:	// Estado 5. Falta de detecção de líquido

		respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
		if( respMotor == 2 || respMotor == 0 ){	// Se não identificou líquido na lavagem
			move_tripa(WAYAHOUR, SPEEDTRP1, 920);	// Move tripa por 920ms velocidade 1
			move_mux(POSITION3,SPEEDMUX1);	// Move mux para a posição 3
			move_tripa(WAYAHOUR, SPEEDTRP4, 5000);	// Move tripa por 5 segundos na velocidade 4
			move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
			writeLine(13);	// Desenha na linha 13
			clearLine(8);
			escrita_texto(210, "Sem amostra. Aspirar novamente?", sizeof("Sem amostra. Aspirar novamente?"));	// Escreve “Sem amostra. Aspirar novamente?”
			estado = 7;	// Estado de verificação de botão para retornar ao início
		}


		break;

	case 7:	// Estado 7. Verificação de botão para retornar ao estado inicial

		readKeyboard = verifyKeyBoard();
		if( readKeyboard == yes ){
			clearLine(7);
			clearLine(8);
			escrita_texto(210, "Levante a sonda para aspirar", sizeof("Levante a sonda para aspirar"));		// Escreve “Levante a sonda para aspirar” na linha 210
			estado = 1;	// Verificação de sonda aberta
		}
		else if( readKeyboard == no ){

			clear_display_text();	// Limpa a tela
			telaManutencao();	// Escreve tela de Manutenção
			return;

		}
		break;
	}

	}

}

void desproteinizacao( void ){

	clear_display_text();	// Apaga a tela
	escrita_texto(7, "DESPROTEINIZA", sizeof("DESPROTEINIZA"));	// Escreve "Desproteinização em andamento"
	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);
	writeLine(13);	// Escreve desenho na tela
	// Escreve "Dissolva completamente a enzima e abra a agulha para aspirar
	escrita_texto(210,"Dissolva completamente a enzima e abra a agulha para aspirar", sizeof("Dissolva completamente a enzima e abra a agulha para aspirar"));
	escrita_texto(450, "Yes=ASP NO=Sair", sizeof("Yes=ASP NO=Sair"));	// Escreve Yes=ASP NO=Sair

	// Declaração das variáveis
	unsigned char estado = 0, minuto = 30, segundo = 59, respMotor = 0, readKeyboard = 0;
	unsigned int temporizador = 0, timeout = 0;

	while(1){

		switch(estado){	// Veriicação de agulha aberta
		case 0:

			if( flag_timer ){	// Se flag timer igual a 1
				flag_timer = 0;	// Flag timer recebe 0
				timeout++;	// Incrementa timeout de 1
				if( timeout >= 60000 || (readKeyboard = verifyKeyBoard()) == no ){	// Se timeout é maior ou igual a 60000 (1 minuto) ou teclado igual a No

					move_mux(POSITION1, SPEEDMUX1);	// Move mux para a posição 1
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Escreve tela de Manutenção
					return;

				}
			}
			else if( agulhaAberta && (readKeyboard = verifyKeyBoard()) == yes ){

				clearLine(7);	// Apaga a linha 7
				clearLine(8);	// Apaga a linha 8
				escrita_texto(210, "Aspirando solu", sizeof("Aspirando solu"));
				// Comandos para escrita de ção
				send_data(0x60);	// Comando para ç
				send_command(0xC0);
				status(1);
				send_data(0x81);	// Comando para Ã
				send_command(0xC0);
				status(1);
				send_data(0x2F);	// Comando para O
				send_command(0xC0);
				status(1);
				escrita_texto(228, "desproteinizante", sizeof("desproteinizante"));
				move_tripa(WAYAHOUR, SPEEDTRP1, 4000);	// Aciona tripa por 4 segundos na velocidade 1
				vTaskDelay(500);	// Delay de 500ms
				respMotor = move_tripa(WAYAHOUR, SPEEDTRP4, 15000); // Aciona tripa por 15 segundos na velocidade 4
				vTaskDelay(500);	// Delay de 500ms
				move_tripa(WAYAHOUR, SPEEDTRP1, 300);	// Aciona tripa por 300ms na velocidade 1
				if( respMotor == 1 ){	// Se detectou líquido
					escrita_texto(210, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
					while( agulhaAberta );	// Enquanto a agulha está aberta, bloqueia o código
					if( agulhaFechada ){

						// Escreve "Desproteinização em andamento"
						escrita_texto(210, "Desproteiniza", sizeof("Desproteiniza"));
						send_data(0x60);	// Comando para ç
						send_command(0xC0);
						status(1);
						send_data(0x81);	// Comando para Ã
						send_command(0xC0);
						status(1);
						send_data(0x2F);	// Comando para O
						send_command(0xC0);
						status(1);
						escrita_texto(232, " em andamento", sizeof(" em andamento"));
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve segundo
						escrita_texto(27, ":", sizeof(":"));	// Escreve :
						escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve minutos - 1
						estado = 1;	// Estado vai para temporizador

					}
				}
				else{


					if( agulhaAberta ){	// Se a agulha está aberta
						escrita_texto(395, "Favor baixar a agulha", sizeof("Favor baixar a agulha"));	// Escreve "Favor baixar a agulha"
						while( agulhaAberta );	// Aguarda até a agulha ser abaixada
					}
					writeLine(13);
					// Escreve "Falta de Sol. Desproteinizante"
					escrita_texto(210, "Falta de Sol. Desproteinizante", sizeof( "Falta de Sol. Desproteinizante"));
					escrita_texto(240,"Aspirar Novamente?", sizeof("Aspirar Novamente?"));	// Escreve "Aspirar novamente?
					estado = 2; // Estado de verificação de comandos

				}
			}
			break;

		case 1:	// Temporizador

			if( minuto > 0 && (readKeyboard = verifyKeyBoard()) != no ){// Enquanto minuto for maior que 0 e teclado diferente de No
				if( flag_timer ){	// Se flag timer ativar
					flag_timer = 0;	// Zera o flag timer
					temporizador--;	// Decrementa o temporizador
					if( temporizador == 0 ){	// Se temporizador chegar a 0
						temporizador = 1000;	// Reinicia o temporizador
						segundo--;
						escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
						if( segundo == 0 ){	// Se segundos for igual a 0
							segundo = 59;	// Reinicia o valor do segundo
							minuto--;	// Minuto decrementa
							if( minuto == 0 ){	// Se temporizador igual a 0 e deu 10 minutos
								estado = 4;
							}
							escrita_texto(25, numtolcd(minuto-1,NUM),3);	// Escreve o minuto
							escrita_texto(28, numtolcd(segundo,NUM), 3);	// Escreve os segundos
						}
					}
				}
			}
			else{

				clear_display_text();	// Limpa a tela
				telaManutencao();	// Desenha tela de manutenção
				respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
				return;	// Retorna a função

			}

			break;

		case 2:	// Verificação de comandos

			readKeyboard = verifyKeyBoard();	// Lê o teclado
			if( readKeyboard == no ){	// Se teclado igual a No
				respMotor = calibA(1);	// Lavando (calib(1)).Faz verificação de líquido. Passa 3 vezes
				if( respMotor == 0 || respMotor == 2 ){	// Se não identificou líquido na lavagem
					clear_display_text();	// Limpa a tela
					telaManutencao();	// Desenha tela de manutenção
					return;	// Retorna a função
				}
			}
			else if( readKeyboard == yes ){	// Senão se teclado igual a yes
				estado = 0;// Estado recebe 0, leitura da sonda e aspiração do desproteinizante
				// Escreve "Dissolva completamente a enzima e abra a agulha para aspirar
				escrita_texto(210,"Dissolva completamente a enzima e abra a agulha para aspirar", sizeof("Dissolva completamente a enzima e abra a agulha para aspirar"));
				escrita_texto(450, "Yes=ASP NO=Sair", sizeof("Yes=ASP NO=Sair"));	// Escreve Yes=ASP NO=Sair
			}

			break;

		}

	}
}


void telaManutencao( void ){

	escrita_texto(11, "MANUTEN", sizeof("MANUTEN"));	// Escreve "MANUTENÇÃO" na posição 11
	// Comandos para escrita de ção
	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);
	escrita_texto(60, "1 CONDICIONAMENTO", sizeof("1 CONDICIONAMENTO"));	// Escreve "1 CONDICIONAMENTO"
	escrita_texto(120, "2 DESPROTEINIZA", sizeof("2 DESPROTEINIZA"));	// Escreve "2 DESPROTEINIZAÇÃO"
	// Comandos para escrita de ção
	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);
	escrita_texto(180, "3 LAVAGEM INTERNA", sizeof("3 LAVAGEM INTERNA"));	// Escreve "3 LAVAGEM INTERNA"
	escrita_texto(240, "4 LIMPEZA DA TUBULA", sizeof("4 LIMPEZA DA TUBULA"));	// Escreve "4 LIMPEZA DA TUBULAÇÃO"
	// Comandos para escrita de ção
	send_data(0x60);	// Comando para ç
	send_command(0xC0);
	status(1);
	send_data(0x81);	// Comando para Ã
	send_command(0xC0);
	status(1);
	send_data(0x2F);	// Comando para O
	send_command(0xC0);
	status(1);
	escrita_texto(450, "1-4=Selecionar NO=Sair", sizeof("1-4=Selecionar NO=Sair"));	// Escreve "1-4=Selecionar NO=Sair"

}

